/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.27
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */


#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};
#endif

/***********************************************************************
 *
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 *
 ************************************************************************/

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
#  if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#    define SWIGTEMPLATEDISAMBIGUATOR template
#  else
#    define SWIGTEMPLATEDISAMBIGUATOR 
#  endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__) || defined(__ICC)
#   define SWIGUNUSED __attribute__ ((unused)) 
# else
#   define SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods for Windows DLLs */
#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   define SWIGEXPORT
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif


/***********************************************************************
 * swigrun.swg
 *
 *     This file contains generic CAPI SWIG runtime support for pointer
 *     type checking.
 *
 ************************************************************************/

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "2"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the swig runtime code.
  In 99.9% of the cases, swig just needs to declare them as 'static'.
  
  But only do this if is strictly necessary, ie, if you have problems
  with your compiler or so.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store inforomation on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;


/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (int)(*f1 - *f2);
  }
  return (l1 - f1) - (l2 - f2);
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/* think of this as a c++ template<> or a scheme macro */
#define SWIG_TypeCheck_Template(comparison, ty)         \
  if (ty) {                                             \
    swig_cast_info *iter = ty->cast;                    \
    while (iter) {                                      \
      if (comparison) {                                 \
        if (iter == ty->cast) return iter;              \
        /* Move iter to the top of the linked list */   \
        iter->prev->next = iter->next;                  \
        if (iter->next)                                 \
          iter->next->prev = iter->prev;                \
        iter->next = ty->cast;                          \
        iter->prev = 0;                                 \
        if (ty->cast) ty->cast->prev = iter;            \
        ty->cast = iter;                                \
        return iter;                                    \
      }                                                 \
      iter = iter->next;                                \
    }                                                   \
  }                                                     \
  return 0

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
}

/* Same as previous function, except strcmp is replaced with a pointer comparison */
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
  SWIG_TypeCheck_Template(iter->type == from, into);
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}


/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu = 0;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/* ---------------------------------------------------------------------- -*- c -*-
 * perl5.swg
 *
 * Perl5 runtime library
 * $Header: /cvsroot/dungeonmaker/perl/DungeonMaker_wrap.cxx,v 1.1.1.1 2005/11/21 20:02:43 acdalton Exp $
 * ----------------------------------------------------------------------------- */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
/* Needed on some windows machines---since MS plays funny games with the header files under C++ */
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* Get rid of free and malloc defined by perl */
#undef free
#undef malloc

#ifndef pTHX_
#define pTHX_
#endif

#include <string.h>
#ifdef __cplusplus
}
#endif

/* Macro to call an XS function */

#ifdef PERL_OBJECT 
#  define SWIG_CALLXS(_name) _name(cv,pPerl) 
#else 
#  ifndef MULTIPLICITY 
#    define SWIG_CALLXS(_name) _name(cv) 
#  else 
#    define SWIG_CALLXS(_name) _name(PERL_GET_THX, cv) 
#  endif 
#endif 

/* Contract support */

#define SWIG_contract_assert(expr,msg) if (!(expr)) { SWIG_croak(msg); } else

/* Note: SwigMagicFuncHack is a typedef used to get the C++ compiler to just shut up already */

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerlObj *pPerl = (CPerlObj *) this;
typedef int (CPerlObj::*SwigMagicFunc)(SV *, MAGIC *);

#ifdef __cplusplus
extern "C" {
#endif
typedef int (CPerlObj::*SwigMagicFuncHack)(SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)
#define SWIGCLASS_STATIC
#else
#define MAGIC_PPERL
#define SWIGCLASS_STATIC static
#ifndef MULTIPLICITY
#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)
typedef int (*SwigMagicFunc)(SV *, MAGIC *);

#ifdef __cplusplus
extern "C" {
#endif
typedef int (*SwigMagicFuncHack)(SV *, MAGIC *);
#ifdef __cplusplus
}
#endif


#else
#define SWIG_MAGIC(a,b) (struct interpreter *interp, SV *a, MAGIC *b)
typedef int (*SwigMagicFunc)(struct interpreter *, SV *, MAGIC *);
#ifdef __cplusplus
extern "C" {
#endif
typedef int (*SwigMagicFuncHack)(struct interpreter *, SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#endif
#endif

#if defined(WIN32) && defined(PERL_OBJECT) && !defined(PerlIO_exportFILE)
#define PerlIO_exportFILE(fh,fl) (FILE*)(fh)
#endif

/* Modifications for newer Perl 5.005 releases */

#if !defined(PERL_REVISION) || ((PERL_REVISION >= 5) && ((PERL_VERSION < 5) || ((PERL_VERSION == 5) && (PERL_SUBVERSION < 50))))
#  ifndef PL_sv_yes
#    define PL_sv_yes sv_yes
#  endif
#  ifndef PL_sv_undef
#    define PL_sv_undef sv_undef
#  endif
#  ifndef PL_na
#    define PL_na na
#  endif
#endif

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_OWNER 1
#define SWIG_SHADOW 2

/* Common SWIG API */

#ifdef PERL_OBJECT
#  define SWIG_ConvertPtr(obj, pp, type, flags) \
     SWIG_Perl_ConvertPtr(pPerl, obj, pp, type, flags)
#  define SWIG_NewPointerObj(p, type, flags) \
     SWIG_Perl_NewPointerObj(pPerl, p, type, flags)
#  define SWIG_MakePackedObj(sv, p, s, type)	\
     SWIG_Perl_MakePackedObj(pPerl, sv, p, s, type)
#  define SWIG_ConvertPacked(obj, p, s, type, flags) \
     SWIG_Perl_ConvertPacked(pPerl, obj, p, s, type, flags)

#else
#  define SWIG_ConvertPtr(obj, pp, type, flags) \
     SWIG_Perl_ConvertPtr(obj, pp, type, flags)
#  define SWIG_NewPointerObj(p, type, flags) \
     SWIG_Perl_NewPointerObj(p, type, flags)
#  define SWIG_MakePackedObj(sv, p, s, type)	\
     SWIG_Perl_MakePackedObj(sv, p, s, type )
#  define SWIG_ConvertPacked(obj, p, s, type, flags) \
     SWIG_Perl_ConvertPacked(obj, p, s, type, flags)
#endif

/* Runtime API */
#define SWIG_GetModule(clientdata) SWIG_Perl_GetModule()
#define SWIG_SetModule(clientdata, pointer) SWIG_Perl_SetModule(pointer)

/* Perl-specific API */
#ifdef PERL_OBJECT
#  define SWIG_MakePtr(sv, ptr, type, flags) \
     SWIG_Perl_MakePtr(pPerl, sv, ptr, type, flags)
#  define SWIG_SetError(str) \
     SWIG_Perl_SetError(pPerl, str)
#else
#  define SWIG_MakePtr(sv, ptr, type, flags) \
     SWIG_Perl_MakePtr(sv, ptr, type, flags)
#  define SWIG_SetError(str) \
     SWIG_Perl_SetError(str)
#  define SWIG_SetErrorSV(str) \
     SWIG_Perl_SetErrorSV(str)
#endif

#define SWIG_SetErrorf SWIG_Perl_SetErrorf


#ifdef PERL_OBJECT
#  define SWIG_MAYBE_PERL_OBJECT CPerlObj *pPerl,
#else
#  define SWIG_MAYBE_PERL_OBJECT
#endif

static swig_cast_info *
SWIG_Perl_TypeCheckRV(SWIG_MAYBE_PERL_OBJECT SV *rv, swig_type_info *ty) {
  SWIG_TypeCheck_Template(sv_derived_from(rv, (char *) iter->type->name), ty);
}

/* Function for getting a pointer value */

static int
SWIG_Perl_ConvertPtr(SWIG_MAYBE_PERL_OBJECT SV *sv, void **ptr, swig_type_info *_t, int flags) {
  swig_cast_info *tc;
  void *voidptr = (void *)0;

  /* If magical, apply more magic */
  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    IV tmp = 0;
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
        mg = mg_find(tsv,'P');
        if (mg) {
          sv = mg->mg_obj;
          if (sv_isobject(sv)) {
            tmp = SvIV((SV*)SvRV(sv));
          }
        }
      } else {
        return -1;
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    voidptr = (void *)tmp;
    if (!_t) {
      *(ptr) = voidptr;
      return 0;
    }
  } else if (! SvOK(sv)) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return 0;
  } else if (SvTYPE(sv) == SVt_RV) {  /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv))
      return 0;
    else
      return -1;
  } else {                            /* Don't know what it is */
    *(ptr) = (void *) 0;
    return -1;
  }
  if (_t) {
    /* Now see if the types match */
    char *_c = HvNAME(SvSTASH(SvRV(sv)));
    tc = SWIG_TypeCheck(_c,_t);
    if (!tc) {
      *ptr = voidptr;
      return -1;
    }
    *ptr = SWIG_TypeCast(tc,voidptr);
    return 0;
  }
  *ptr = voidptr;
  return 0;
}

static void
SWIG_Perl_MakePtr(SWIG_MAYBE_PERL_OBJECT SV *sv, void *ptr, swig_type_info *t, int flags) {
  if (ptr && (flags & SWIG_SHADOW)) {
    SV *self;
    SV *obj=newSV(0);
    HV *hash=newHV();
    HV *stash;
    sv_setref_pv(obj, (char *) t->name, ptr);
    stash=SvSTASH(SvRV(obj));
    if (flags & SWIG_OWNER) {
      HV *hv;
      GV *gv=*(GV**)hv_fetch(stash, "OWNER", 5, TRUE);
      if (!isGV(gv))
        gv_init(gv, stash, "OWNER", 5, FALSE);
      hv=GvHVn(gv);
      hv_store_ent(hv, obj, newSViv(1), 0);
    }
    sv_magic((SV *)hash, (SV *)obj, 'P', Nullch, 0);
    SvREFCNT_dec(obj);
    self=newRV_noinc((SV *)hash);
    sv_setsv(sv, self);
    SvREFCNT_dec((SV *)self);
    sv_bless(sv, stash);
  }
  else {
    sv_setref_pv(sv, (char *) t->name, ptr);
  }
}

static SWIGINLINE SV *
SWIG_Perl_NewPointerObj(SWIG_MAYBE_PERL_OBJECT void *ptr, swig_type_info *t, int flags) {
  SV *result = sv_newmortal();
  SWIG_MakePtr(result, ptr, t, flags);
  return result;
}

static void
  SWIG_Perl_MakePackedObj(SWIG_MAYBE_PERL_OBJECT SV *sv, void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  sv_setpv(sv, result);
}

/* Convert a packed value value */
static int
SWIG_Perl_ConvertPacked(SWIG_MAYBE_PERL_OBJECT SV *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_cast_info *tc;
  const char  *c = 0;

  if ((!obj) || (!SvOK(obj))) return -1;
  c = SvPV(obj, PL_na);
  /* Pointer values must start with leading underscore */
  if (*c != '_') return -1;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) return -1;
  }
  return 0;
}

static SWIGINLINE void
SWIG_Perl_SetError(SWIG_MAYBE_PERL_OBJECT const char *error) {
  if (error) sv_setpv(perl_get_sv("@", TRUE), error);
}

static SWIGINLINE void
SWIG_Perl_SetErrorSV(SWIG_MAYBE_PERL_OBJECT SV *error) {
  if (error) sv_setsv(perl_get_sv("@", TRUE), error);
}

static void
SWIG_Perl_SetErrorf(const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  sv_vsetpvfn(perl_get_sv("@", TRUE), fmt, strlen(fmt), &args, Null(SV**), 0, Null(bool*));
  va_end(args);
}

/* Macros for low-level exception handling */
#define SWIG_fail       goto fail
#define SWIG_croak(x)   { SWIG_SetError(x); goto fail; }
#define SWIG_croakSV(x) { SWIG_SetErrorSV(x); goto fail; }
/* most preprocessors do not support vararg macros :-( */
/* #define SWIG_croakf(x...) { SWIG_SetErrorf(x); goto fail; } */


typedef XS(SwigPerlWrapper);
typedef SwigPerlWrapper *SwigPerlWrapperPtr;

/* Structure for command table */
typedef struct {
  const char         *name;
  SwigPerlWrapperPtr  wrapper;
} swig_command_info;

/* Information for constant table */

#define SWIG_INT     1
#define SWIG_FLOAT   2
#define SWIG_STRING  3
#define SWIG_POINTER 4
#define SWIG_BINARY  5

/* Constant information structure */
typedef struct swig_constant_info {
    int              type;
    const char      *name;
    long             lvalue;
    double           dvalue;
    void            *pvalue;
    swig_type_info **ptype;
} swig_constant_info;

#ifdef __cplusplus
}
#endif

/* Structure for variable table */
typedef struct {
  const char   *name;
  SwigMagicFunc   set;
  SwigMagicFunc   get;
  swig_type_info  **type;
} swig_variable_info;

/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
  #ifndef MULTIPLICITY
     static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) {
  #else
     static void _swig_create_magic(SV *sv, char *name, int (*set)(struct interpreter*, SV *, MAGIC *), int (*get)(struct interpreter*, SV *,MAGIC *)) {
  #endif
#else
#  define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerlObj *pPerl, SV *sv, const char *name, int (CPerlObj::*set)(SV *, MAGIC *), int (CPerlObj::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',(char *) name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = (SwigMagicFuncHack) get;
  mg->mg_virtual->svt_set = (SwigMagicFuncHack) set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}


static swig_module_info *
SWIG_Perl_GetModule() {
  static void *type_pointer = (void *)0;
  SV *pointer;

  /* first check if pointer already created */
  if (!type_pointer) {
    pointer = get_sv("swig_runtime_data::type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, FALSE);
    if (pointer && SvOK(pointer)) {
      type_pointer = INT2PTR(swig_type_info **, SvIV(pointer));
    }
  }

  return (swig_module_info *) type_pointer;
}

static void
SWIG_Perl_SetModule(swig_module_info *module) {
  SV *pointer;

  /* create a new pointer */
  pointer = get_sv("swig_runtime_data::type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, TRUE);
  sv_setiv(pointer, PTR2IV(module));
}

#ifdef do_open
  #undef do_open
#endif
#ifdef do_close
  #undef do_close
#endif
#ifdef scalar
  #undef scalar
#endif
#ifdef list
  #undef list
#endif
#ifdef apply
  #undef apply
#endif
#ifdef convert
  #undef convert
#endif
#ifdef Error
  #undef Error
#endif
#ifdef form
  #undef form
#endif
#ifdef vform
  #undef vform
#endif
#ifdef LABEL
  #undef LABEL
#endif
#ifdef METHOD
  #undef METHOD
#endif
#ifdef Move
  #undef Move
#endif
#ifdef yylex
  #undef yylex
#endif
#ifdef yyparse
  #undef yyparse
#endif
#ifdef yyerror
  #undef yyerror
#endif
#ifdef invert
  #undef invert
#endif
#ifdef ref
  #undef ref
#endif
#ifdef ENTER
  #undef ENTER
#endif
#ifdef read
  #undef read
#endif
#ifdef write
  #undef write
#endif
#ifdef eof
  #undef eof
#endif
#ifdef bool
  #undef bool
#endif
#ifdef close
  #undef close
#endif
#ifdef rewind
  #undef rewind
#endif



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_alifegames__Builder swig_types[0]
#define SWIGTYPE_p_alifegames__Config swig_types[1]
#define SWIGTYPE_p_alifegames__CrawlerData swig_types[2]
#define SWIGTYPE_p_alifegames__DungeonMaker swig_types[3]
#define SWIGTYPE_p_alifegames__FlagsDirs swig_types[4]
#define SWIGTYPE_p_alifegames__IntCoordinate swig_types[5]
#define SWIGTYPE_p_alifegames__RectFill swig_types[6]
#define SWIGTYPE_p_alifegames__Room swig_types[7]
#define SWIGTYPE_p_alifegames__RoomComp swig_types[8]
#define SWIGTYPE_p_alifegames__Roomie swig_types[9]
#define SWIGTYPE_p_alifegames__SpawnInfo swig_types[10]
#define SWIGTYPE_p_alifegames__SquareInfo swig_types[11]
#define SWIGTYPE_p_alifegames__TripleInt swig_types[12]
#define SWIGTYPE_p_alifegames__Tunneler swig_types[13]
#define SWIGTYPE_p_alifegames__TunnelerData swig_types[14]
#define SWIGTYPE_p_alifegames__WallCrawler swig_types[15]
#define SWIGTYPE_p_int swig_types[16]
#define SWIGTYPE_p_std__pairTint_int_t swig_types[17]
#define SWIGTYPE_p_std__vectorTalifegames__CrawlerData_t swig_types[18]
#define SWIGTYPE_p_std__vectorTalifegames__Direction_t swig_types[19]
#define SWIGTYPE_p_std__vectorTalifegames__IntCoordinate_t swig_types[20]
#define SWIGTYPE_p_std__vectorTalifegames__RectFill_t swig_types[21]
#define SWIGTYPE_p_std__vectorTalifegames__Room_t swig_types[22]
#define SWIGTYPE_p_std__vectorTalifegames__SpawnInfo_t swig_types[23]
#define SWIGTYPE_p_std__vectorTalifegames__SquareInfo_t swig_types[24]
#define SWIGTYPE_p_std__vectorTalifegames__TripleInt_t swig_types[25]
#define SWIGTYPE_p_std__vectorTalifegames__TunnelerData_t swig_types[26]
#define SWIGTYPE_p_std__vectorTint_t swig_types[27]
#define SWIGTYPE_p_std__vectorTstd__pairTalifegames__CrawlerData_alifegames__CrawlerData_t_t swig_types[28]
#define SWIGTYPE_p_std__vectorTstd__vectorTalifegames__SquareInfo_t_t swig_types[29]
static swig_type_info *swig_types[31];
static swig_module_info swig_module = {swig_types, 30, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    boot_Games__DungeonMaker

#define SWIG_name   "Games::DungeonMakerc::boot_Games__DungeonMaker"
#define SWIG_prefix "Games::DungeonMakerc::"

#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
#ifndef MULTIPLICITY
SWIGEXPORT void SWIG_init (CV* cv);
#else
SWIGEXPORT void SWIG_init (pTHXo_ CV* cv);
#endif
#else
SWIGEXPORT void SWIG_init (CV *cv, CPerlObj *);
#endif


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


#define SWIG_exception(a,b)   SWIG_croak(b)


#include <stdexcept>


#include <string>

double SwigSvToNumber(SV* sv) {
    return SvIOK(sv) ? double(SvIVX(sv)) : SvNVX(sv);
}
std::string SwigSvToString(SV* sv) {
    STRLEN len;
    return SvPV(sv,len);
}
void SwigSvFromString(SV* sv, const std::string& s) {
    sv_setpv(sv,s.c_str());
}


#include <utility>


#include <vector>
#include <algorithm>
#include <stdexcept>


#include "DungeonMaker.h"

#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_Games::DungeonMaker_var::
class _wrap_Games::DungeonMaker_var : public CPerlObj {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(pTHX_ SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}


#ifdef PERL_OBJECT
};
#endif

#ifdef __cplusplus
extern "C" {
#endif
XS(_wrap_new_pair_ii__SWIG_0) {
    {
        std::pair<int,int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_pair_ii();");
        }
        result = (std::pair<int,int > *)new std::pair<int,int >();
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__pairTint_int_t, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_pair_ii__SWIG_1) {
    {
        int arg1 ;
        int arg2 ;
        std::pair<int,int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: new_pair_ii(t,u);");
        }
        arg1 = (int) SvIV(ST(0));
        arg2 = (int) SvIV(ST(1));
        result = (std::pair<int,int > *)new std::pair<int,int >(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__pairTint_int_t, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_pair_ii__SWIG_2) {
    {
        std::pair<int,int > *arg1 = 0 ;
        std::pair<int,int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: new_pair_ii(p);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_std__pairTint_int_t,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_pair_ii. Expected _p_std__pairTint_int_t");
            }
        }
        result = (std::pair<int,int > *)new std::pair<int,int >((std::pair<int,int > const &)*arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__pairTint_int_t, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_pair_ii) {
    dXSARGS;
    
    if (items == 0) {
        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_pair_ii__SWIG_0); return;
    }
    if (items == 1) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_std__pairTint_int_t, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_pair_ii__SWIG_2); return;
        }
    }
    if (items == 2) {
        int _v;
        {
            _v = SvIOK(ST(0)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = SvIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_pair_ii__SWIG_1); return;
            }
        }
    }
    
    croak("No matching function for overloaded 'new_pair_ii'");
    XSRETURN(0);
}


XS(_wrap_pair_ii_first_set) {
    {
        std::pair<int,int > *arg1 = (std::pair<int,int > *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: pair_ii_first_set(self,first);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_std__pairTint_int_t,0) < 0) {
                SWIG_croak("Type error in argument 1 of pair_ii_first_set. Expected _p_std__pairTint_int_t");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->first = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_pair_ii_first_get) {
    {
        std::pair<int,int > *arg1 = (std::pair<int,int > *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: pair_ii_first_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_std__pairTint_int_t,0) < 0) {
                SWIG_croak("Type error in argument 1 of pair_ii_first_get. Expected _p_std__pairTint_int_t");
            }
        }
        result = (int) ((arg1)->first);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_pair_ii_second_set) {
    {
        std::pair<int,int > *arg1 = (std::pair<int,int > *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: pair_ii_second_set(self,second);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_std__pairTint_int_t,0) < 0) {
                SWIG_croak("Type error in argument 1 of pair_ii_second_set. Expected _p_std__pairTint_int_t");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->second = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_pair_ii_second_get) {
    {
        std::pair<int,int > *arg1 = (std::pair<int,int > *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: pair_ii_second_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_std__pairTint_int_t,0) < 0) {
                SWIG_croak("Type error in argument 1 of pair_ii_second_get. Expected _p_std__pairTint_int_t");
            }
        }
        result = (int) ((arg1)->second);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_pair_ii) {
    {
        std::pair<int,int > *arg1 = (std::pair<int,int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_pair_ii(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_std__pairTint_int_t,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_pair_ii. Expected _p_std__pairTint_int_t");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_IntCoordinate__SWIG_0) {
    {
        alifegames::IntCoordinate *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_IntCoordinate();");
        }
        result = (alifegames::IntCoordinate *)new alifegames::IntCoordinate();
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__IntCoordinate, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_IntCoordinate__SWIG_1) {
    {
        int arg1 ;
        int arg2 ;
        alifegames::IntCoordinate *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: new_IntCoordinate(x,y);");
        }
        arg1 = (int) SvIV(ST(0));
        arg2 = (int) SvIV(ST(1));
        result = (alifegames::IntCoordinate *)new alifegames::IntCoordinate(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__IntCoordinate, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_IntCoordinate_ShowX) {
    {
        alifegames::IntCoordinate *arg1 = (alifegames::IntCoordinate *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: IntCoordinate_ShowX(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 1 of IntCoordinate_ShowX. Expected _p_alifegames__IntCoordinate");
            }
        }
        result = (int)(arg1)->ShowX();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_IntCoordinate_ShowY) {
    {
        alifegames::IntCoordinate *arg1 = (alifegames::IntCoordinate *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: IntCoordinate_ShowY(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 1 of IntCoordinate_ShowY. Expected _p_alifegames__IntCoordinate");
            }
        }
        result = (int)(arg1)->ShowY();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_IntCoordinate__SWIG_2) {
    {
        alifegames::IntCoordinate *arg1 = 0 ;
        alifegames::IntCoordinate *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: new_IntCoordinate(Coord);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_IntCoordinate. Expected _p_alifegames__IntCoordinate");
            }
        }
        result = (alifegames::IntCoordinate *)new alifegames::IntCoordinate((alifegames::IntCoordinate const &)*arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__IntCoordinate, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_IntCoordinate) {
    dXSARGS;
    
    if (items == 0) {
        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_IntCoordinate__SWIG_0); return;
    }
    if (items == 1) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_alifegames__IntCoordinate, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_IntCoordinate__SWIG_2); return;
        }
    }
    if (items == 2) {
        int _v;
        {
            _v = SvIOK(ST(0)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = SvIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_IntCoordinate__SWIG_1); return;
            }
        }
    }
    
    croak("No matching function for overloaded 'new_IntCoordinate'");
    XSRETURN(0);
}


XS(_wrap_delete_IntCoordinate) {
    {
        alifegames::IntCoordinate *arg1 = (alifegames::IntCoordinate *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_IntCoordinate(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_IntCoordinate. Expected _p_alifegames__IntCoordinate");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TransformDirection) {
    {
        alifegames::Direction arg1 ;
        alifegames::IntCoordinate result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TransformDirection(d);");
        }
        arg1 = (alifegames::Direction) SvIV(ST(0));
        result = alifegames::TransformDirection(arg1);
        
        {
            alifegames::IntCoordinate * resultobj = new alifegames::IntCoordinate((alifegames::IntCoordinate &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_alifegames__IntCoordinate, SWIG_SHADOW|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SquareInfo_xCoord_set) {
    {
        alifegames::SquareInfo *arg1 = (alifegames::SquareInfo *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SquareInfo_xCoord_set(self,xCoord);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__SquareInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of SquareInfo_xCoord_set. Expected _p_alifegames__SquareInfo");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->xCoord = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SquareInfo_xCoord_get) {
    {
        alifegames::SquareInfo *arg1 = (alifegames::SquareInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: SquareInfo_xCoord_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__SquareInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of SquareInfo_xCoord_get. Expected _p_alifegames__SquareInfo");
            }
        }
        result = (int) ((arg1)->xCoord);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SquareInfo_yCoord_set) {
    {
        alifegames::SquareInfo *arg1 = (alifegames::SquareInfo *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SquareInfo_yCoord_set(self,yCoord);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__SquareInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of SquareInfo_yCoord_set. Expected _p_alifegames__SquareInfo");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->yCoord = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SquareInfo_yCoord_get) {
    {
        alifegames::SquareInfo *arg1 = (alifegames::SquareInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: SquareInfo_yCoord_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__SquareInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of SquareInfo_yCoord_get. Expected _p_alifegames__SquareInfo");
            }
        }
        result = (int) ((arg1)->yCoord);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SquareInfo_type_set) {
    {
        alifegames::SquareInfo *arg1 = (alifegames::SquareInfo *) 0 ;
        alifegames::SquareData arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SquareInfo_type_set(self,type);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__SquareInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of SquareInfo_type_set. Expected _p_alifegames__SquareInfo");
            }
        }
        arg2 = (alifegames::SquareData) SvIV(ST(1));
        if (arg1) (arg1)->type = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SquareInfo_type_get) {
    {
        alifegames::SquareInfo *arg1 = (alifegames::SquareInfo *) 0 ;
        alifegames::SquareData result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: SquareInfo_type_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__SquareInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of SquareInfo_type_get. Expected _p_alifegames__SquareInfo");
            }
        }
        result = (alifegames::SquareData) ((arg1)->type);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_SquareInfo__SWIG_0) {
    {
        int arg1 ;
        int arg2 ;
        alifegames::SquareData arg3 ;
        alifegames::SquareInfo *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: new_SquareInfo(x,y,t);");
        }
        arg1 = (int) SvIV(ST(0));
        arg2 = (int) SvIV(ST(1));
        arg3 = (alifegames::SquareData) SvIV(ST(2));
        result = (alifegames::SquareInfo *)new alifegames::SquareInfo(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__SquareInfo, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_SquareInfo__SWIG_1) {
    {
        alifegames::SquareInfo *arg1 = 0 ;
        alifegames::SquareInfo *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: new_SquareInfo(data);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__SquareInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_SquareInfo. Expected _p_alifegames__SquareInfo");
            }
        }
        result = (alifegames::SquareInfo *)new alifegames::SquareInfo((alifegames::SquareInfo const &)*arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__SquareInfo, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_SquareInfo) {
    dXSARGS;
    
    if (items == 1) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_alifegames__SquareInfo, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_SquareInfo__SWIG_1); return;
        }
    }
    if (items == 3) {
        int _v;
        {
            _v = SvIOK(ST(0)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = SvIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = SvIOK(ST(2)) ? 1 : 0;
                }
                if (_v) {
                    (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_SquareInfo__SWIG_0); return;
                }
            }
        }
    }
    
    croak("No matching function for overloaded 'new_SquareInfo'");
    XSRETURN(0);
}


XS(_wrap_delete_SquareInfo) {
    {
        alifegames::SquareInfo *arg1 = (alifegames::SquareInfo *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_SquareInfo(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__SquareInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_SquareInfo. Expected _p_alifegames__SquareInfo");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpawnInfo_xCoord_set) {
    {
        alifegames::SpawnInfo *arg1 = (alifegames::SpawnInfo *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SpawnInfo_xCoord_set(self,xCoord);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__SpawnInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpawnInfo_xCoord_set. Expected _p_alifegames__SpawnInfo");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->xCoord = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpawnInfo_xCoord_get) {
    {
        alifegames::SpawnInfo *arg1 = (alifegames::SpawnInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: SpawnInfo_xCoord_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__SpawnInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpawnInfo_xCoord_get. Expected _p_alifegames__SpawnInfo");
            }
        }
        result = (int) ((arg1)->xCoord);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpawnInfo_yCoord_set) {
    {
        alifegames::SpawnInfo *arg1 = (alifegames::SpawnInfo *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SpawnInfo_yCoord_set(self,yCoord);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__SpawnInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpawnInfo_yCoord_set. Expected _p_alifegames__SpawnInfo");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->yCoord = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpawnInfo_yCoord_get) {
    {
        alifegames::SpawnInfo *arg1 = (alifegames::SpawnInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: SpawnInfo_yCoord_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__SpawnInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpawnInfo_yCoord_get. Expected _p_alifegames__SpawnInfo");
            }
        }
        result = (int) ((arg1)->yCoord);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpawnInfo_type_set) {
    {
        alifegames::SpawnInfo *arg1 = (alifegames::SpawnInfo *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: SpawnInfo_type_set(self,type);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__SpawnInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpawnInfo_type_set. Expected _p_alifegames__SpawnInfo");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->type = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_SpawnInfo_type_get) {
    {
        alifegames::SpawnInfo *arg1 = (alifegames::SpawnInfo *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: SpawnInfo_type_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__SpawnInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of SpawnInfo_type_get. Expected _p_alifegames__SpawnInfo");
            }
        }
        result = (int) ((arg1)->type);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_SpawnInfo__SWIG_0) {
    {
        alifegames::SpawnInfo *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_SpawnInfo();");
        }
        result = (alifegames::SpawnInfo *)new alifegames::SpawnInfo();
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__SpawnInfo, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_SpawnInfo__SWIG_1) {
    {
        int arg1 ;
        int arg2 ;
        int arg3 ;
        alifegames::SpawnInfo *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: new_SpawnInfo(x,y,t);");
        }
        arg1 = (int) SvIV(ST(0));
        arg2 = (int) SvIV(ST(1));
        arg3 = (int) SvIV(ST(2));
        result = (alifegames::SpawnInfo *)new alifegames::SpawnInfo(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__SpawnInfo, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_SpawnInfo) {
    dXSARGS;
    
    if (items == 0) {
        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_SpawnInfo__SWIG_0); return;
    }
    if (items == 3) {
        int _v;
        {
            _v = SvIOK(ST(0)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = SvIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = SvIOK(ST(2)) ? 1 : 0;
                }
                if (_v) {
                    (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_SpawnInfo__SWIG_1); return;
                }
            }
        }
    }
    
    croak("No matching function for overloaded 'new_SpawnInfo'");
    XSRETURN(0);
}


XS(_wrap_delete_SpawnInfo) {
    {
        alifegames::SpawnInfo *arg1 = (alifegames::SpawnInfo *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_SpawnInfo(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__SpawnInfo,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_SpawnInfo. Expected _p_alifegames__SpawnInfo");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TripleInt_sm_set) {
    {
        alifegames::TripleInt *arg1 = (alifegames::TripleInt *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TripleInt_sm_set(self,sm);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TripleInt,0) < 0) {
                SWIG_croak("Type error in argument 1 of TripleInt_sm_set. Expected _p_alifegames__TripleInt");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->sm = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TripleInt_sm_get) {
    {
        alifegames::TripleInt *arg1 = (alifegames::TripleInt *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TripleInt_sm_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TripleInt,0) < 0) {
                SWIG_croak("Type error in argument 1 of TripleInt_sm_get. Expected _p_alifegames__TripleInt");
            }
        }
        result = (int) ((arg1)->sm);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TripleInt_md_set) {
    {
        alifegames::TripleInt *arg1 = (alifegames::TripleInt *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TripleInt_md_set(self,md);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TripleInt,0) < 0) {
                SWIG_croak("Type error in argument 1 of TripleInt_md_set. Expected _p_alifegames__TripleInt");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->md = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TripleInt_md_get) {
    {
        alifegames::TripleInt *arg1 = (alifegames::TripleInt *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TripleInt_md_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TripleInt,0) < 0) {
                SWIG_croak("Type error in argument 1 of TripleInt_md_get. Expected _p_alifegames__TripleInt");
            }
        }
        result = (int) ((arg1)->md);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TripleInt_lg_set) {
    {
        alifegames::TripleInt *arg1 = (alifegames::TripleInt *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TripleInt_lg_set(self,lg);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TripleInt,0) < 0) {
                SWIG_croak("Type error in argument 1 of TripleInt_lg_set. Expected _p_alifegames__TripleInt");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->lg = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TripleInt_lg_get) {
    {
        alifegames::TripleInt *arg1 = (alifegames::TripleInt *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TripleInt_lg_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TripleInt,0) < 0) {
                SWIG_croak("Type error in argument 1 of TripleInt_lg_get. Expected _p_alifegames__TripleInt");
            }
        }
        result = (int) ((arg1)->lg);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_TripleInt__SWIG_0) {
    {
        alifegames::TripleInt *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_TripleInt();");
        }
        result = (alifegames::TripleInt *)new alifegames::TripleInt();
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__TripleInt, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_TripleInt__SWIG_1) {
    {
        int arg1 ;
        int arg2 ;
        int arg3 ;
        alifegames::TripleInt *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: new_TripleInt(s,m,l);");
        }
        arg1 = (int) SvIV(ST(0));
        arg2 = (int) SvIV(ST(1));
        arg3 = (int) SvIV(ST(2));
        result = (alifegames::TripleInt *)new alifegames::TripleInt(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__TripleInt, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_TripleInt) {
    dXSARGS;
    
    if (items == 0) {
        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_TripleInt__SWIG_0); return;
    }
    if (items == 3) {
        int _v;
        {
            _v = SvIOK(ST(0)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = SvIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = SvIOK(ST(2)) ? 1 : 0;
                }
                if (_v) {
                    (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_TripleInt__SWIG_1); return;
                }
            }
        }
    }
    
    croak("No matching function for overloaded 'new_TripleInt'");
    XSRETURN(0);
}


XS(_wrap_delete_TripleInt) {
    {
        alifegames::TripleInt *arg1 = (alifegames::TripleInt *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_TripleInt(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TripleInt,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_TripleInt. Expected _p_alifegames__TripleInt");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_FlagsDirs_checked_set) {
    {
        alifegames::FlagsDirs *arg1 = (alifegames::FlagsDirs *) 0 ;
        unsigned char arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: FlagsDirs_checked_set(self,checked);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__FlagsDirs,0) < 0) {
                SWIG_croak("Type error in argument 1 of FlagsDirs_checked_set. Expected _p_alifegames__FlagsDirs");
            }
        }
        arg2 = (unsigned char) SvUV(ST(1));
        if (arg1) (arg1)->checked = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_FlagsDirs_checked_get) {
    {
        alifegames::FlagsDirs *arg1 = (alifegames::FlagsDirs *) 0 ;
        unsigned char result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: FlagsDirs_checked_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__FlagsDirs,0) < 0) {
                SWIG_croak("Type error in argument 1 of FlagsDirs_checked_get. Expected _p_alifegames__FlagsDirs");
            }
        }
        result = (unsigned char) ((arg1)->checked);
        
        ST(argvi) = sv_newmortal();
        sv_setuv(ST(argvi++), (UV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_FlagsDirs__SWIG_0) {
    {
        alifegames::FlagsDirs *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_FlagsDirs();");
        }
        result = (alifegames::FlagsDirs *)new alifegames::FlagsDirs();
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__FlagsDirs, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_FlagsDirs__SWIG_1) {
    {
        unsigned char arg1 ;
        alifegames::FlagsDirs *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: new_FlagsDirs(in);");
        }
        arg1 = (unsigned char) SvUV(ST(0));
        result = (alifegames::FlagsDirs *)new alifegames::FlagsDirs(arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__FlagsDirs, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_FlagsDirs) {
    dXSARGS;
    
    if (items == 0) {
        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_FlagsDirs__SWIG_0); return;
    }
    if (items == 1) {
        int _v;
        {
            _v = SvIOK(ST(0)) ? 1 : 0;
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_FlagsDirs__SWIG_1); return;
        }
    }
    
    croak("No matching function for overloaded 'new_FlagsDirs'");
    XSRETURN(0);
}


XS(_wrap_delete_FlagsDirs) {
    {
        alifegames::FlagsDirs *arg1 = (alifegames::FlagsDirs *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_FlagsDirs(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__FlagsDirs,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_FlagsDirs. Expected _p_alifegames__FlagsDirs");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_RectFill_startX_set) {
    {
        alifegames::RectFill *arg1 = (alifegames::RectFill *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: RectFill_startX_set(self,startX);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__RectFill,0) < 0) {
                SWIG_croak("Type error in argument 1 of RectFill_startX_set. Expected _p_alifegames__RectFill");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->startX = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_RectFill_startX_get) {
    {
        alifegames::RectFill *arg1 = (alifegames::RectFill *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: RectFill_startX_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__RectFill,0) < 0) {
                SWIG_croak("Type error in argument 1 of RectFill_startX_get. Expected _p_alifegames__RectFill");
            }
        }
        result = (int) ((arg1)->startX);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_RectFill_startY_set) {
    {
        alifegames::RectFill *arg1 = (alifegames::RectFill *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: RectFill_startY_set(self,startY);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__RectFill,0) < 0) {
                SWIG_croak("Type error in argument 1 of RectFill_startY_set. Expected _p_alifegames__RectFill");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->startY = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_RectFill_startY_get) {
    {
        alifegames::RectFill *arg1 = (alifegames::RectFill *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: RectFill_startY_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__RectFill,0) < 0) {
                SWIG_croak("Type error in argument 1 of RectFill_startY_get. Expected _p_alifegames__RectFill");
            }
        }
        result = (int) ((arg1)->startY);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_RectFill_endX_set) {
    {
        alifegames::RectFill *arg1 = (alifegames::RectFill *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: RectFill_endX_set(self,endX);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__RectFill,0) < 0) {
                SWIG_croak("Type error in argument 1 of RectFill_endX_set. Expected _p_alifegames__RectFill");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->endX = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_RectFill_endX_get) {
    {
        alifegames::RectFill *arg1 = (alifegames::RectFill *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: RectFill_endX_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__RectFill,0) < 0) {
                SWIG_croak("Type error in argument 1 of RectFill_endX_get. Expected _p_alifegames__RectFill");
            }
        }
        result = (int) ((arg1)->endX);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_RectFill_endY_set) {
    {
        alifegames::RectFill *arg1 = (alifegames::RectFill *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: RectFill_endY_set(self,endY);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__RectFill,0) < 0) {
                SWIG_croak("Type error in argument 1 of RectFill_endY_set. Expected _p_alifegames__RectFill");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->endY = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_RectFill_endY_get) {
    {
        alifegames::RectFill *arg1 = (alifegames::RectFill *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: RectFill_endY_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__RectFill,0) < 0) {
                SWIG_croak("Type error in argument 1 of RectFill_endY_get. Expected _p_alifegames__RectFill");
            }
        }
        result = (int) ((arg1)->endY);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_RectFill_type_set) {
    {
        alifegames::RectFill *arg1 = (alifegames::RectFill *) 0 ;
        alifegames::SquareData arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: RectFill_type_set(self,type);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__RectFill,0) < 0) {
                SWIG_croak("Type error in argument 1 of RectFill_type_set. Expected _p_alifegames__RectFill");
            }
        }
        arg2 = (alifegames::SquareData) SvIV(ST(1));
        if (arg1) (arg1)->type = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_RectFill_type_get) {
    {
        alifegames::RectFill *arg1 = (alifegames::RectFill *) 0 ;
        alifegames::SquareData result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: RectFill_type_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__RectFill,0) < 0) {
                SWIG_croak("Type error in argument 1 of RectFill_type_get. Expected _p_alifegames__RectFill");
            }
        }
        result = (alifegames::SquareData) ((arg1)->type);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_RectFill) {
    {
        int arg1 ;
        int arg2 ;
        int arg3 ;
        int arg4 ;
        alifegames::SquareData arg5 ;
        alifegames::RectFill *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: new_RectFill(sX,sY,eX,eY,t);");
        }
        arg1 = (int) SvIV(ST(0));
        arg2 = (int) SvIV(ST(1));
        arg3 = (int) SvIV(ST(2));
        arg4 = (int) SvIV(ST(3));
        arg5 = (alifegames::SquareData) SvIV(ST(4));
        result = (alifegames::RectFill *)new alifegames::RectFill(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__RectFill, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_RectFill) {
    {
        alifegames::RectFill *arg1 = (alifegames::RectFill *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_RectFill(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__RectFill,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_RectFill. Expected _p_alifegames__RectFill");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_loc_set) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        alifegames::IntCoordinate *arg2 = (alifegames::IntCoordinate *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: CrawlerData_loc_set(self,loc);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_loc_set. Expected _p_alifegames__CrawlerData");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of CrawlerData_loc_set. Expected _p_alifegames__IntCoordinate");
            }
        }
        if (arg1) (arg1)->loc = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_loc_get) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        alifegames::IntCoordinate *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: CrawlerData_loc_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_loc_get. Expected _p_alifegames__CrawlerData");
            }
        }
        result = (alifegames::IntCoordinate *)& ((arg1)->loc);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__IntCoordinate, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_dir_set) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        alifegames::IntCoordinate *arg2 = (alifegames::IntCoordinate *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: CrawlerData_dir_set(self,dir);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_dir_set. Expected _p_alifegames__CrawlerData");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of CrawlerData_dir_set. Expected _p_alifegames__IntCoordinate");
            }
        }
        if (arg1) (arg1)->dir = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_dir_get) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        alifegames::IntCoordinate *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: CrawlerData_dir_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_dir_get. Expected _p_alifegames__CrawlerData");
            }
        }
        result = (alifegames::IntCoordinate *)& ((arg1)->dir);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__IntCoordinate, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_intDir_set) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        alifegames::IntCoordinate *arg2 = (alifegames::IntCoordinate *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: CrawlerData_intDir_set(self,intDir);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_intDir_set. Expected _p_alifegames__CrawlerData");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of CrawlerData_intDir_set. Expected _p_alifegames__IntCoordinate");
            }
        }
        if (arg1) (arg1)->intDir = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_intDir_get) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        alifegames::IntCoordinate *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: CrawlerData_intDir_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_intDir_get. Expected _p_alifegames__CrawlerData");
            }
        }
        result = (alifegames::IntCoordinate *)& ((arg1)->intDir);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__IntCoordinate, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_age_set) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: CrawlerData_age_set(self,age);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_age_set. Expected _p_alifegames__CrawlerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->age = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_age_get) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: CrawlerData_age_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_age_get. Expected _p_alifegames__CrawlerData");
            }
        }
        result = (int) ((arg1)->age);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_maxAge_set) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: CrawlerData_maxAge_set(self,maxAge);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_maxAge_set. Expected _p_alifegames__CrawlerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->maxAge = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_maxAge_get) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: CrawlerData_maxAge_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_maxAge_get. Expected _p_alifegames__CrawlerData");
            }
        }
        result = (int) ((arg1)->maxAge);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_gen_set) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: CrawlerData_gen_set(self,gen);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_gen_set. Expected _p_alifegames__CrawlerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->gen = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_gen_get) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: CrawlerData_gen_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_gen_get. Expected _p_alifegames__CrawlerData");
            }
        }
        result = (int) ((arg1)->gen);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_sL_set) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: CrawlerData_sL_set(self,sL);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_sL_set. Expected _p_alifegames__CrawlerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->sL = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_sL_get) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: CrawlerData_sL_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_sL_get. Expected _p_alifegames__CrawlerData");
            }
        }
        result = (int) ((arg1)->sL);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_op_set) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: CrawlerData_op_set(self,op);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_op_set. Expected _p_alifegames__CrawlerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->op = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_op_get) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: CrawlerData_op_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_op_get. Expected _p_alifegames__CrawlerData");
            }
        }
        result = (int) ((arg1)->op);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_cW_set) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: CrawlerData_cW_set(self,cW);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_cW_set. Expected _p_alifegames__CrawlerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->cW = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_cW_get) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: CrawlerData_cW_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_cW_get. Expected _p_alifegames__CrawlerData");
            }
        }
        result = (int) ((arg1)->cW);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_sSSP_set) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: CrawlerData_sSSP_set(self,sSSP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_sSSP_set. Expected _p_alifegames__CrawlerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->sSSP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_sSSP_get) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: CrawlerData_sSSP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_sSSP_get. Expected _p_alifegames__CrawlerData");
            }
        }
        result = (int) ((arg1)->sSSP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_sDSP_set) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: CrawlerData_sDSP_set(self,sDSP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_sDSP_set. Expected _p_alifegames__CrawlerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->sDSP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_sDSP_get) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: CrawlerData_sDSP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_sDSP_get. Expected _p_alifegames__CrawlerData");
            }
        }
        result = (int) ((arg1)->sDSP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_tSSP_set) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: CrawlerData_tSSP_set(self,tSSP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_tSSP_set. Expected _p_alifegames__CrawlerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->tSSP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_tSSP_get) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: CrawlerData_tSSP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_tSSP_get. Expected _p_alifegames__CrawlerData");
            }
        }
        result = (int) ((arg1)->tSSP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_tDSP_set) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: CrawlerData_tDSP_set(self,tDSP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_tDSP_set. Expected _p_alifegames__CrawlerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->tDSP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_tDSP_get) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: CrawlerData_tDSP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_tDSP_get. Expected _p_alifegames__CrawlerData");
            }
        }
        result = (int) ((arg1)->tDSP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_cDP_set) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: CrawlerData_cDP_set(self,cDP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_cDP_set. Expected _p_alifegames__CrawlerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->cDP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_CrawlerData_cDP_get) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: CrawlerData_cDP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of CrawlerData_cDP_get. Expected _p_alifegames__CrawlerData");
            }
        }
        result = (int) ((arg1)->cDP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_CrawlerData) {
    {
        alifegames::CrawlerData *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_CrawlerData();");
        }
        result = (alifegames::CrawlerData *)new alifegames::CrawlerData();
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__CrawlerData, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_CrawlerData) {
    {
        alifegames::CrawlerData *arg1 = (alifegames::CrawlerData *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_CrawlerData(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_CrawlerData. Expected _p_alifegames__CrawlerData");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_loc_set) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        alifegames::IntCoordinate *arg2 = (alifegames::IntCoordinate *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TunnelerData_loc_set(self,loc);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_loc_set. Expected _p_alifegames__TunnelerData");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of TunnelerData_loc_set. Expected _p_alifegames__IntCoordinate");
            }
        }
        if (arg1) (arg1)->loc = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_loc_get) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        alifegames::IntCoordinate *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TunnelerData_loc_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_loc_get. Expected _p_alifegames__TunnelerData");
            }
        }
        result = (alifegames::IntCoordinate *)& ((arg1)->loc);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__IntCoordinate, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_dir_set) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        alifegames::IntCoordinate *arg2 = (alifegames::IntCoordinate *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TunnelerData_dir_set(self,dir);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_dir_set. Expected _p_alifegames__TunnelerData");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of TunnelerData_dir_set. Expected _p_alifegames__IntCoordinate");
            }
        }
        if (arg1) (arg1)->dir = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_dir_get) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        alifegames::IntCoordinate *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TunnelerData_dir_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_dir_get. Expected _p_alifegames__TunnelerData");
            }
        }
        result = (alifegames::IntCoordinate *)& ((arg1)->dir);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__IntCoordinate, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_intDir_set) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        alifegames::IntCoordinate *arg2 = (alifegames::IntCoordinate *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TunnelerData_intDir_set(self,intDir);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_intDir_set. Expected _p_alifegames__TunnelerData");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of TunnelerData_intDir_set. Expected _p_alifegames__IntCoordinate");
            }
        }
        if (arg1) (arg1)->intDir = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_intDir_get) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        alifegames::IntCoordinate *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TunnelerData_intDir_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_intDir_get. Expected _p_alifegames__TunnelerData");
            }
        }
        result = (alifegames::IntCoordinate *)& ((arg1)->intDir);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__IntCoordinate, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_age_set) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TunnelerData_age_set(self,age);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_age_set. Expected _p_alifegames__TunnelerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->age = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_age_get) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TunnelerData_age_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_age_get. Expected _p_alifegames__TunnelerData");
            }
        }
        result = (int) ((arg1)->age);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_maxAge_set) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TunnelerData_maxAge_set(self,maxAge);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_maxAge_set. Expected _p_alifegames__TunnelerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->maxAge = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_maxAge_get) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TunnelerData_maxAge_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_maxAge_get. Expected _p_alifegames__TunnelerData");
            }
        }
        result = (int) ((arg1)->maxAge);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_gen_set) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TunnelerData_gen_set(self,gen);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_gen_set. Expected _p_alifegames__TunnelerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->gen = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_gen_get) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TunnelerData_gen_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_gen_get. Expected _p_alifegames__TunnelerData");
            }
        }
        result = (int) ((arg1)->gen);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_sL_set) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TunnelerData_sL_set(self,sL);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_sL_set. Expected _p_alifegames__TunnelerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->sL = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_sL_get) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TunnelerData_sL_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_sL_get. Expected _p_alifegames__TunnelerData");
            }
        }
        result = (int) ((arg1)->sL);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_tW_set) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TunnelerData_tW_set(self,tW);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_tW_set. Expected _p_alifegames__TunnelerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->tW = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_tW_get) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TunnelerData_tW_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_tW_get. Expected _p_alifegames__TunnelerData");
            }
        }
        result = (int) ((arg1)->tW);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_sDSP_set) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TunnelerData_sDSP_set(self,sDSP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_sDSP_set. Expected _p_alifegames__TunnelerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->sDSP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_sDSP_get) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TunnelerData_sDSP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_sDSP_get. Expected _p_alifegames__TunnelerData");
            }
        }
        result = (int) ((arg1)->sDSP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_tDSP_set) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TunnelerData_tDSP_set(self,tDSP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_tDSP_set. Expected _p_alifegames__TunnelerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->tDSP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_tDSP_get) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TunnelerData_tDSP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_tDSP_get. Expected _p_alifegames__TunnelerData");
            }
        }
        result = (int) ((arg1)->tDSP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_cDP_set) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TunnelerData_cDP_set(self,cDP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_cDP_set. Expected _p_alifegames__TunnelerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->cDP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_cDP_get) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TunnelerData_cDP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_cDP_get. Expected _p_alifegames__TunnelerData");
            }
        }
        result = (int) ((arg1)->cDP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_mRRP_set) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TunnelerData_mRRP_set(self,mRRP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_mRRP_set. Expected _p_alifegames__TunnelerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->mRRP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_mRRP_get) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TunnelerData_mRRP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_mRRP_get. Expected _p_alifegames__TunnelerData");
            }
        }
        result = (int) ((arg1)->mRRP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_mRLP_set) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TunnelerData_mRLP_set(self,mRLP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_mRLP_set. Expected _p_alifegames__TunnelerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->mRLP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_mRLP_get) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TunnelerData_mRLP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_mRLP_get. Expected _p_alifegames__TunnelerData");
            }
        }
        result = (int) ((arg1)->mRLP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_jP_set) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: TunnelerData_jP_set(self,jP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_jP_set. Expected _p_alifegames__TunnelerData");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->jP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_TunnelerData_jP_get) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: TunnelerData_jP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of TunnelerData_jP_get. Expected _p_alifegames__TunnelerData");
            }
        }
        result = (int) ((arg1)->jP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_TunnelerData) {
    {
        alifegames::TunnelerData *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_TunnelerData();");
        }
        result = (alifegames::TunnelerData *)new alifegames::TunnelerData();
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__TunnelerData, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_TunnelerData) {
    {
        alifegames::TunnelerData *arg1 = (alifegames::TunnelerData *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_TunnelerData(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_TunnelerData. Expected _p_alifegames__TunnelerData");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Room__SWIG_0) {
    {
        SwigValueWrapper<std::vector<alifegames::IntCoordinate > > arg1 ;
        alifegames::Room *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: new_Room(ins);");
        }
        {
            std::vector<alifegames::IntCoordinate > * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_std__vectorTalifegames__IntCoordinate_t,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_Room. Expected _p_std__vectorTalifegames__IntCoordinate_t");
            }
            arg1 = *argp;
        }
        result = (alifegames::Room *)new alifegames::Room(arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__Room, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Room__SWIG_1) {
    {
        alifegames::Room *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_Room();");
        }
        result = (alifegames::Room *)new alifegames::Room();
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__Room, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Room) {
    dXSARGS;
    
    if (items == 0) {
        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_Room__SWIG_1); return;
    }
    if (items == 1) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_std__vectorTalifegames__IntCoordinate_t, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_Room__SWIG_0); return;
        }
    }
    
    croak("No matching function for overloaded 'new_Room'");
    XSRETURN(0);
}


XS(_wrap_delete_Room) {
    {
        alifegames::Room *arg1 = (alifegames::Room *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_Room(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Room,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_Room. Expected _p_alifegames__Room");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Room_AddSquare) {
    {
        alifegames::Room *arg1 = (alifegames::Room *) 0 ;
        alifegames::IntCoordinate arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Room_AddSquare(self,square);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Room,0) < 0) {
                SWIG_croak("Type error in argument 1 of Room_AddSquare. Expected _p_alifegames__Room");
            }
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of Room_AddSquare. Expected _p_alifegames__IntCoordinate");
            }
            arg2 = *argp;
        }
        (arg1)->AddSquare(arg2);
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Room_GetInside) {
    {
        alifegames::Room *arg1 = (alifegames::Room *) 0 ;
        SwigValueWrapper<std::vector<alifegames::IntCoordinate > > result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Room_GetInside(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Room,0) < 0) {
                SWIG_croak("Type error in argument 1 of Room_GetInside. Expected _p_alifegames__Room");
            }
        }
        result = (arg1)->GetInside();
        
        {
            std::vector<alifegames::IntCoordinate > * resultobj = new std::vector<alifegames::IntCoordinate >((std::vector<alifegames::IntCoordinate > &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_std__vectorTalifegames__IntCoordinate_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Room_SetInDungeon) {
    {
        alifegames::Room *arg1 = (alifegames::Room *) 0 ;
        bool arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Room_SetInDungeon(self,iD);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Room,0) < 0) {
                SWIG_croak("Type error in argument 1 of Room_SetInDungeon. Expected _p_alifegames__Room");
            }
        }
        arg2 = SvIV(ST(1)) ? true : false;
        (arg1)->SetInDungeon(arg2);
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Room_GetInDungeon) {
    {
        alifegames::Room *arg1 = (alifegames::Room *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Room_GetInDungeon(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Room,0) < 0) {
                SWIG_croak("Type error in argument 1 of Room_GetInDungeon. Expected _p_alifegames__Room");
            }
        }
        result = (bool)(arg1)->GetInDungeon();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Room_GetSize) {
    {
        alifegames::Room *arg1 = (alifegames::Room *) 0 ;
        unsigned int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Room_GetSize(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Room,0) < 0) {
                SWIG_croak("Type error in argument 1 of Room_GetSize. Expected _p_alifegames__Room");
            }
        }
        result = (unsigned int)(arg1)->GetSize();
        
        ST(argvi) = sv_newmortal();
        sv_setuv(ST(argvi++), (UV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Room_GetRandomSquare) {
    {
        alifegames::Room *arg1 = (alifegames::Room *) 0 ;
        alifegames::IntCoordinate result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Room_GetRandomSquare(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Room,0) < 0) {
                SWIG_croak("Type error in argument 1 of Room_GetRandomSquare. Expected _p_alifegames__Room");
            }
        }
        result = (arg1)->GetRandomSquare();
        
        {
            alifegames::IntCoordinate * resultobj = new alifegames::IntCoordinate((alifegames::IntCoordinate &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_alifegames__IntCoordinate, SWIG_SHADOW|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_RoomComp) {
    {
        alifegames::RoomComp *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_RoomComp();");
        }
        result = (alifegames::RoomComp *)new alifegames::RoomComp();
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__RoomComp, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_RoomComp) {
    {
        alifegames::RoomComp *arg1 = (alifegames::RoomComp *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_RoomComp(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__RoomComp,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_RoomComp. Expected _p_alifegames__RoomComp");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_dX_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_dX_set(self,dX);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_dX_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->dX = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_dX_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_dX_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_dX_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->dX);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_dY_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_dY_set(self,dY);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_dY_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->dY = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_dY_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_dY_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_dY_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->dY);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_bg_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        alifegames::SquareData arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_bg_set(self,bg);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_bg_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (alifegames::SquareData) SvIV(ST(1));
        if (arg1) (arg1)->bg = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_bg_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        alifegames::SquareData result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_bg_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_bg_get. Expected _p_alifegames__Config");
            }
        }
        result = (alifegames::SquareData) ((arg1)->bg);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_op_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<alifegames::Direction > *arg2 = (std::vector<alifegames::Direction > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_op_set(self,op);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_op_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTalifegames__Direction_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_op_set. Expected _p_std__vectorTalifegames__Direction_t");
            }
        }
        if (arg1) (arg1)->op = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_op_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<alifegames::Direction > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_op_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_op_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<alifegames::Direction > *)& ((arg1)->op);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTalifegames__Direction_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_des_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<alifegames::RectFill > *arg2 = (std::vector<alifegames::RectFill > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_des_set(self,des);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_des_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTalifegames__RectFill_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_des_set. Expected _p_std__vectorTalifegames__RectFill_t");
            }
        }
        if (arg1) (arg1)->des = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_des_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<alifegames::RectFill > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_des_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_des_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<alifegames::RectFill > *)& ((arg1)->des);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTalifegames__RectFill_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_SL_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_SL_set(self,SL);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_SL_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_SL_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->SL = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_SL_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_SL_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_SL_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->SL);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_CW_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_CW_set(self,CW);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_CW_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_CW_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->CW = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_CW_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_CW_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_CW_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->CW);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_MAC_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_MAC_set(self,MAC);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_MAC_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_MAC_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->MAC = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_MAC_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_MAC_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_MAC_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->MAC);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_MAT_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_MAT_set(self,MAT);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_MAT_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_MAT_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->MAT = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_MAT_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_MAT_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_MAT_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->MAT);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_Crawlers_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<alifegames::CrawlerData > *arg2 = (std::vector<alifegames::CrawlerData > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_Crawlers_set(self,Crawlers);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_Crawlers_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTalifegames__CrawlerData_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_Crawlers_set. Expected _p_std__vectorTalifegames__CrawlerData_t");
            }
        }
        if (arg1) (arg1)->Crawlers = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_Crawlers_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<alifegames::CrawlerData > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_Crawlers_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_Crawlers_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<alifegames::CrawlerData > *)& ((arg1)->Crawlers);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTalifegames__CrawlerData_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_Tunnelers_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<alifegames::TunnelerData > *arg2 = (std::vector<alifegames::TunnelerData > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_Tunnelers_set(self,Tunnelers);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_Tunnelers_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTalifegames__TunnelerData_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_Tunnelers_set. Expected _p_std__vectorTalifegames__TunnelerData_t");
            }
        }
        if (arg1) (arg1)->Tunnelers = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_Tunnelers_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<alifegames::TunnelerData > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_Tunnelers_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_Tunnelers_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<alifegames::TunnelerData > *)& ((arg1)->Tunnelers);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTalifegames__TunnelerData_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_CrawlerPairs_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<std::pair<alifegames::CrawlerData,alifegames::CrawlerData > > *arg2 = (std::vector<std::pair<alifegames::CrawlerData,alifegames::CrawlerData > > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_CrawlerPairs_set(self,CrawlerPairs);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_CrawlerPairs_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTstd__pairTalifegames__CrawlerData_alifegames__CrawlerData_t_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_CrawlerPairs_set. Expected _p_std__vectorTstd__pairTalifegames__CrawlerData_alifegames__CrawlerData_t_t");
            }
        }
        if (arg1) (arg1)->CrawlerPairs = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_CrawlerPairs_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<std::pair<alifegames::CrawlerData,alifegames::CrawlerData > > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_CrawlerPairs_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_CrawlerPairs_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<std::pair<alifegames::CrawlerData,alifegames::CrawlerData > > *)& ((arg1)->CrawlerPairs);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTstd__pairTalifegames__CrawlerData_alifegames__CrawlerData_t_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_BDPFGT_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_BDPFGT_set(self,BDPFGT);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_BDPFGT_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_BDPFGT_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->BDPFGT = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_BDPFGT_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_BDPFGT_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_BDPFGT_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->BDPFGT);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_BDPFGC_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_BDPFGC_set(self,BDPFGC);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_BDPFGC_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_BDPFGC_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->BDPFGC = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_BDPFGC_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_BDPFGC_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_BDPFGC_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->BDPFGC);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_BDPFGR_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_BDPFGR_set(self,BDPFGR);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_BDPFGR_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_BDPFGR_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->BDPFGR = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_BDPFGR_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_BDPFGR_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_BDPFGR_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->BDPFGR);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_RSPS_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<alifegames::TripleInt > *arg2 = (std::vector<alifegames::TripleInt > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_RSPS_set(self,RSPS);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_RSPS_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTalifegames__TripleInt_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_RSPS_set. Expected _p_std__vectorTalifegames__TripleInt_t");
            }
        }
        if (arg1) (arg1)->RSPS = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_RSPS_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<alifegames::TripleInt > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_RSPS_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_RSPS_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<alifegames::TripleInt > *)& ((arg1)->RSPS);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTalifegames__TripleInt_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_RSPB_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<alifegames::TripleInt > *arg2 = (std::vector<alifegames::TripleInt > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_RSPB_set(self,RSPB);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_RSPB_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTalifegames__TripleInt_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_RSPB_set. Expected _p_std__vectorTalifegames__TripleInt_t");
            }
        }
        if (arg1) (arg1)->RSPB = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_RSPB_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<alifegames::TripleInt > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_RSPB_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_RSPB_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<alifegames::TripleInt > *)& ((arg1)->RSPB);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTalifegames__TripleInt_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_mut_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_mut_set(self,mut);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_mut_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->mut = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_mut_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_mut_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_mut_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->mut);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_nHP_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_nHP_set(self,nHP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_nHP_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->nHP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_nHP_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_nHP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_nHP_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->nHP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_jD_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_jD_set(self,jD);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_jD_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->jD = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_jD_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_jD_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_jD_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->jD);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_minRS_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_minRS_set(self,minRS);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_minRS_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->minRS = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_minRS_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_minRS_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_minRS_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->minRS);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_medRS_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_medRS_set(self,medRS);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_medRS_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->medRS = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_medRS_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_medRS_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_medRS_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->medRS);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_larRS_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_larRS_set(self,larRS);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_larRS_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->larRS = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_larRS_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_larRS_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_larRS_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->larRS);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_maxRS_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_maxRS_set(self,maxRS);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_maxRS_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->maxRS = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_maxRS_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_maxRS_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_maxRS_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->maxRS);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_numSmallL_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_numSmallL_set(self,numSmallL);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_numSmallL_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->numSmallL = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_numSmallL_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_numSmallL_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_numSmallL_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->numSmallL);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_numMedL_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_numMedL_set(self,numMedL);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_numMedL_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->numMedL = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_numMedL_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_numMedL_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_numMedL_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->numMedL);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_numLarL_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_numLarL_set(self,numLarL);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_numLarL_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->numLarL = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_numLarL_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_numLarL_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_numLarL_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->numLarL);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_numSmallD_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_numSmallD_set(self,numSmallD);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_numSmallD_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->numSmallD = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_numSmallD_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_numSmallD_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_numSmallD_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->numSmallD);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_numMedD_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_numMedD_set(self,numMedD);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_numMedD_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->numMedD = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_numMedD_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_numMedD_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_numMedD_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->numMedD);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_numLarD_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_numLarD_set(self,numLarD);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_numLarD_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->numLarD = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_numLarD_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_numLarD_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_numLarD_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->numLarD);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_rCPG_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_rCPG_set(self,rCPG);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_rCPG_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_rCPG_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->rCPG = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_rCPG_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_rCPG_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_rCPG_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->rCPG);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_rC_sSSP_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_rC_sSSP_set(self,rC_sSSP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_rC_sSSP_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->rC_sSSP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_rC_sSSP_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_rC_sSSP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_rC_sSSP_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->rC_sSSP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_rC_sDSP_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_rC_sDSP_set(self,rC_sDSP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_rC_sDSP_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->rC_sDSP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_rC_sDSP_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_rC_sDSP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_rC_sDSP_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->rC_sDSP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_rC_tSSP_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_rC_tSSP_set(self,rC_tSSP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_rC_tSSP_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->rC_tSSP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_rC_tSSP_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_rC_tSSP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_rC_tSSP_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->rC_tSSP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_rC_tDSP_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_rC_tDSP_set(self,rC_tDSP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_rC_tDSP_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->rC_tDSP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_rC_tDSP_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_rC_tDSP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_rC_tDSP_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->rC_tDSP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_rC_cDP_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_rC_cDP_set(self,rC_cDP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_rC_cDP_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->rC_cDP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_rC_cDP_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_rC_cDP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_rC_cDP_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->rC_cDP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_jP_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_jP_set(self,jP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_jP_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_jP_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->jP = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_jP_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_jP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_jP_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->jP);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_sUpP_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_sUpP_set(self,sUpP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_sUpP_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_sUpP_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->sUpP = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_sUpP_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_sUpP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_sUpP_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->sUpP);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_sDownP_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_sDownP_set(self,sDownP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_sDownP_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_sDownP_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->sDownP = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_sDownP_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_sDownP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_sDownP_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->sDownP);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_pat_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_pat_set(self,pat);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_pat_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->pat = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_pat_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_pat_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_pat_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->pat);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_tJD_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_tJD_set(self,tJD);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_tJD_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->tJD = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_tJD_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_tJD_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_tJD_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->tJD);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_sUGD_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_sUGD_set(self,sUGD);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_sUGD_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->sUGD = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_sUGD_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_sUGD_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_sUGD_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->sUGD);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_cIT_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        bool arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_cIT_set(self,cIT);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_cIT_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = SvIV(ST(1)) ? true : false;
        if (arg1) (arg1)->cIT = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_cIT_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_cIT_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_cIT_get. Expected _p_alifegames__Config");
            }
        }
        result = (bool) ((arg1)->cIT);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_rAR_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        double arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_rAR_set(self,rAR);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_rAR_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (double) SvNV(ST(1));
        
        if (arg1) (arg1)->rAR = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_rAR_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_rAR_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_rAR_get. Expected _p_alifegames__Config");
            }
        }
        result = (double) ((arg1)->rAR);
        
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_aRP_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_aRP_set(self,aRP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_aRP_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_aRP_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->aRP = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_aRP_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_aRP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_aRP_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->aRP);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSUOAR_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_gSUOAR_set(self,gSUOAR);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSUOAR_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->gSUOAR = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSUOAR_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_gSUOAR_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSUOAR_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->gSUOAR);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_crIT_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        bool arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_crIT_set(self,crIT);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_crIT_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = SvIV(ST(1)) ? true : false;
        if (arg1) (arg1)->crIT = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_crIT_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_crIT_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_crIT_get. Expected _p_alifegames__Config");
            }
        }
        result = (bool) ((arg1)->crIT);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_crIA_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        bool arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_crIA_set(self,crIA);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_crIA_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = SvIV(ST(1)) ? true : false;
        if (arg1) (arg1)->crIA = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_crIA_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_crIA_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_crIA_get. Expected _p_alifegames__Config");
            }
        }
        result = (bool) ((arg1)->crIA);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_sCIT_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_sCIT_set(self,sCIT);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_sCIT_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->sCIT = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_sCIT_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_sCIT_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_sCIT_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->sCIT);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_showM_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        bool arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_showM_set(self,showM);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_showM_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = SvIV(ST(1)) ? true : false;
        if (arg1) (arg1)->showM = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_showM_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_showM_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_showM_get. Expected _p_alifegames__Config");
            }
        }
        result = (bool) ((arg1)->showM);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_storeM_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        bool arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_storeM_set(self,storeM);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_storeM_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = SvIV(ST(1)) ? true : false;
        if (arg1) (arg1)->storeM = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_storeM_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_storeM_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_storeM_get. Expected _p_alifegames__Config");
            }
        }
        result = (bool) ((arg1)->storeM);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_TCS_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        alifegames::CrawlerData *arg2 = (alifegames::CrawlerData *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_TCS_set(self,TCS);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_TCS_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_alifegames__CrawlerData,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_TCS_set. Expected _p_alifegames__CrawlerData");
            }
        }
        if (arg1) (arg1)->TCS = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_TCS_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        alifegames::CrawlerData *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_TCS_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_TCS_get. Expected _p_alifegames__Config");
            }
        }
        result = (alifegames::CrawlerData *)& ((arg1)->TCS);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__CrawlerData, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_randSeed_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        unsigned int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_randSeed_set(self,randSeed);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_randSeed_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (unsigned int) SvUV(ST(1));
        if (arg1) (arg1)->randSeed = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_randSeed_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        unsigned int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_randSeed_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_randSeed_get. Expected _p_alifegames__Config");
            }
        }
        result = (unsigned int) ((arg1)->randSeed);
        
        ST(argvi) = sv_newmortal();
        sv_setuv(ST(argvi++), (UV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_MLR_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_MLR_set(self,MLR);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_MLR_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_MLR_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->MLR = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_MLR_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_MLR_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_MLR_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->MLR);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_MLO_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_MLO_set(self,MLO);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_MLO_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_MLO_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->MLO = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_MLO_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_MLO_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_MLO_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->MLO);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_MDR_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_MDR_set(self,MDR);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_MDR_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_MDR_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->MDR = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_MDR_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_MDR_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_MDR_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->MDR);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_MDO_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_MDO_set(self,MDO);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_MDO_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_MDO_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->MDO = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_MDO_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_MDO_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_MDO_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->MDO);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_TIL_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_TIL_set(self,TIL);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_TIL_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_TIL_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->TIL = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_TIL_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_TIL_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_TIL_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->TIL);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_TID_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *arg2 = (std::vector<int > *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_TID_set(self,TID);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_TID_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_std__vectorTint_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_TID_set. Expected _p_std__vectorTint_t");
            }
        }
        if (arg1) (arg1)->TID = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_TID_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        std::vector<int > *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_TID_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_TID_get. Expected _p_alifegames__Config");
            }
        }
        result = (std::vector<int > *)& ((arg1)->TID);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_std__vectorTint_t, 0|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSMOBLR_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_gSMOBLR_set(self,gSMOBLR);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSMOBLR_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->gSMOBLR = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSMOBLR_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_gSMOBLR_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSMOBLR_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->gSMOBLR);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSMOBDR_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_gSMOBDR_set(self,gSMOBDR);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSMOBDR_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->gSMOBDR = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSMOBDR_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_gSMOBDR_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSMOBDR_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->gSMOBDR);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSTreasL_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_gSTreasL_set(self,gSTreasL);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSTreasL_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->gSTreasL = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSTreasL_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_gSTreasL_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSTreasL_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->gSTreasL);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSTreasD_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_gSTreasD_set(self,gSTreasD);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSTreasD_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->gSTreasD = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSTreasD_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_gSTreasD_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSTreasD_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->gSTreasD);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSVMOBLR_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_gSVMOBLR_set(self,gSVMOBLR);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSVMOBLR_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->gSVMOBLR = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSVMOBLR_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_gSVMOBLR_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSVMOBLR_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->gSVMOBLR);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSVMOBDR_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_gSVMOBDR_set(self,gSVMOBDR);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSVMOBDR_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->gSVMOBDR = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSVMOBDR_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_gSVMOBDR_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSVMOBDR_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->gSVMOBDR);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSVTreasL_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_gSVTreasL_set(self,gSVTreasL);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSVTreasL_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->gSVTreasL = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSVTreasL_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_gSVTreasL_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSVTreasL_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->gSVTreasL);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSVTreasD_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_gSVTreasD_set(self,gSVTreasD);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSVTreasD_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->gSVTreasD = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gSVTreasD_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_gSVTreasD_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gSVTreasD_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->gSVTreasD);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_iARP_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_iARP_set(self,iARP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_iARP_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->iARP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_iARP_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_iARP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_iARP_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->iARP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_tCG_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_tCG_set(self,tCG);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_tCG_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->tCG = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_tCG_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_tCG_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_tCG_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->tCG);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_tCCP_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_tCCP_set(self,tCCP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_tCCP_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->tCCP = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_tCCP_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_tCCP_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_tCCP_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->tCCP);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_lCT_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        alifegames::TunnelerData *arg2 = (alifegames::TunnelerData *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_lCT_set(self,lCT);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_lCT_set. Expected _p_alifegames__Config");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_alifegames__TunnelerData,0) < 0) {
                SWIG_croak("Type error in argument 2 of Config_lCT_set. Expected _p_alifegames__TunnelerData");
            }
        }
        if (arg1) (arg1)->lCT = *arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_lCT_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        alifegames::TunnelerData *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_lCT_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_lCT_get. Expected _p_alifegames__Config");
            }
        }
        result = (alifegames::TunnelerData *)& ((arg1)->lCT);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__TunnelerData, SWIG_SHADOW|0);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gDLC_set) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_gDLC_set(self,gDLC);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gDLC_set. Expected _p_alifegames__Config");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->gDLC = arg2;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_gDLC_get) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Config_gDLC_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_gDLC_get. Expected _p_alifegames__Config");
            }
        }
        result = (int) ((arg1)->gDLC);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Config__SWIG_0) {
    {
        alifegames::Config *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_Config();");
        }
        result = (alifegames::Config *)new alifegames::Config();
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__Config, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Config__SWIG_1) {
    {
        int arg1 ;
        int arg2 ;
        alifegames::Config *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: new_Config(x,y);");
        }
        arg1 = (int) SvIV(ST(0));
        arg2 = (int) SvIV(ST(1));
        result = (alifegames::Config *)new alifegames::Config(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__Config, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Config) {
    dXSARGS;
    
    if (items == 0) {
        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_Config__SWIG_0); return;
    }
    if (items == 2) {
        int _v;
        {
            _v = SvIOK(ST(0)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = SvIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_new_Config__SWIG_1); return;
            }
        }
    }
    
    croak("No matching function for overloaded 'new_Config'");
    XSRETURN(0);
}


XS(_wrap_Config_ReadDesign) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        char *arg2 = (char *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_ReadDesign(self,dF);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_ReadDesign. Expected _p_alifegames__Config");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (bool)(arg1)->ReadDesign(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_AcceptDesign) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        char *arg2 = (char *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Config_AcceptDesign(self,dF);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_AcceptDesign. Expected _p_alifegames__Config");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (bool)(arg1)->AcceptDesign((char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Config_ValidateDirections) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        alifegames::Direction arg2 ;
        alifegames::Direction arg3 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: Config_ValidateDirections(self,d,iD);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of Config_ValidateDirections. Expected _p_alifegames__Config");
            }
        }
        arg2 = (alifegames::Direction) SvIV(ST(1));
        arg3 = (alifegames::Direction) SvIV(ST(2));
        result = (bool)(arg1)->ValidateDirections(arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_Config) {
    {
        alifegames::Config *arg1 = (alifegames::Config *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_Config(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_Config. Expected _p_alifegames__Config");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_Builder) {
    {
        alifegames::Builder *arg1 = (alifegames::Builder *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_Builder(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Builder,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_Builder. Expected _p_alifegames__Builder");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Builder_StepAhead) {
    {
        alifegames::Builder *arg1 = (alifegames::Builder *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Builder_StepAhead(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Builder,0) < 0) {
                SWIG_croak("Type error in argument 1 of Builder_StepAhead. Expected _p_alifegames__Builder");
            }
        }
        result = (bool)(arg1)->StepAhead();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Builder_GetAge) {
    {
        alifegames::Builder *arg1 = (alifegames::Builder *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Builder_GetAge(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Builder,0) < 0) {
                SWIG_croak("Type error in argument 1 of Builder_GetAge. Expected _p_alifegames__Builder");
            }
        }
        result = (int)(arg1)->GetAge();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Builder_GetGeneration) {
    {
        alifegames::Builder *arg1 = (alifegames::Builder *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Builder_GetGeneration(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Builder,0) < 0) {
                SWIG_croak("Type error in argument 1 of Builder_GetGeneration. Expected _p_alifegames__Builder");
            }
        }
        result = (int)(arg1)->GetGeneration();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Builder_AdvanceAge) {
    {
        alifegames::Builder *arg1 = (alifegames::Builder *) 0 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: Builder_AdvanceAge(self,adv);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Builder,0) < 0) {
                SWIG_croak("Type error in argument 1 of Builder_AdvanceAge. Expected _p_alifegames__Builder");
            }
        }
        arg2 = (int) SvIV(ST(1));
        (arg1)->AdvanceAge(arg2);
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_WallCrawler) {
    {
        alifegames::WallCrawler *arg1 = (alifegames::WallCrawler *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_WallCrawler(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__WallCrawler,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_WallCrawler. Expected _p_alifegames__WallCrawler");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_WallCrawler) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::IntCoordinate arg2 ;
        alifegames::IntCoordinate arg3 ;
        int arg4 ;
        int arg5 ;
        int arg6 ;
        alifegames::IntCoordinate arg7 ;
        int arg8 ;
        int arg9 ;
        int arg10 ;
        int arg11 ;
        int arg12 ;
        int arg13 ;
        int arg14 ;
        int arg15 ;
        alifegames::WallCrawler *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 15) || (items > 15)) {
            SWIG_croak("Usage: new_WallCrawler(pdm,loc,fwd,a,mA,g,intDir,sL,o,cW,sSSP,sDSP,tSSP,tDSP,cDP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_WallCrawler. Expected _p_alifegames__DungeonMaker");
            }
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of new_WallCrawler. Expected _p_alifegames__IntCoordinate");
            }
            arg2 = *argp;
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 3 of new_WallCrawler. Expected _p_alifegames__IntCoordinate");
            }
            arg3 = *argp;
        }
        arg4 = (int) SvIV(ST(3));
        arg5 = (int) SvIV(ST(4));
        arg6 = (int) SvIV(ST(5));
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(6),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 7 of new_WallCrawler. Expected _p_alifegames__IntCoordinate");
            }
            arg7 = *argp;
        }
        arg8 = (int) SvIV(ST(7));
        arg9 = (int) SvIV(ST(8));
        arg10 = (int) SvIV(ST(9));
        arg11 = (int) SvIV(ST(10));
        arg12 = (int) SvIV(ST(11));
        arg13 = (int) SvIV(ST(12));
        arg14 = (int) SvIV(ST(13));
        arg15 = (int) SvIV(ST(14));
        result = (alifegames::WallCrawler *)new alifegames::WallCrawler(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__WallCrawler, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_WallCrawler_FrontFree) {
    {
        alifegames::WallCrawler *arg1 = (alifegames::WallCrawler *) 0 ;
        alifegames::IntCoordinate arg2 ;
        alifegames::IntCoordinate arg3 ;
        int *arg4 = 0 ;
        int *arg5 = 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: WallCrawler_FrontFree(self,Position,Heading,leftFree,rightFree);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__WallCrawler,0) < 0) {
                SWIG_croak("Type error in argument 1 of WallCrawler_FrontFree. Expected _p_alifegames__WallCrawler");
            }
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of WallCrawler_FrontFree. Expected _p_alifegames__IntCoordinate");
            }
            arg2 = *argp;
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 3 of WallCrawler_FrontFree. Expected _p_alifegames__IntCoordinate");
            }
            arg3 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 4 of WallCrawler_FrontFree. Expected _p_int");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 5 of WallCrawler_FrontFree. Expected _p_int");
            }
        }
        result = (int)(arg1)->FrontFree(arg2,arg3,*arg4,*arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_WallCrawler_StepAhead) {
    {
        alifegames::WallCrawler *arg1 = (alifegames::WallCrawler *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: WallCrawler_StepAhead(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__WallCrawler,0) < 0) {
                SWIG_croak("Type error in argument 1 of WallCrawler_StepAhead. Expected _p_alifegames__WallCrawler");
            }
        }
        result = (bool)(arg1)->StepAhead();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_Tunneler) {
    {
        alifegames::Tunneler *arg1 = (alifegames::Tunneler *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_Tunneler(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Tunneler,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_Tunneler. Expected _p_alifegames__Tunneler");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Tunneler) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::IntCoordinate arg2 ;
        alifegames::IntCoordinate arg3 ;
        int arg4 ;
        int arg5 ;
        int arg6 ;
        alifegames::IntCoordinate arg7 ;
        int arg8 ;
        int arg9 ;
        int arg10 ;
        int arg11 ;
        int arg12 ;
        int arg13 ;
        int arg14 ;
        int arg15 ;
        alifegames::Tunneler *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 15) || (items > 15)) {
            SWIG_croak("Usage: new_Tunneler(pdm,loc,fwd,a,mA,g,intDir,sL,tW,sDSP,tDSP,cDP,mRRP,mRLP,jP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_Tunneler. Expected _p_alifegames__DungeonMaker");
            }
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of new_Tunneler. Expected _p_alifegames__IntCoordinate");
            }
            arg2 = *argp;
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 3 of new_Tunneler. Expected _p_alifegames__IntCoordinate");
            }
            arg3 = *argp;
        }
        arg4 = (int) SvIV(ST(3));
        arg5 = (int) SvIV(ST(4));
        arg6 = (int) SvIV(ST(5));
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(6),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 7 of new_Tunneler. Expected _p_alifegames__IntCoordinate");
            }
            arg7 = *argp;
        }
        arg8 = (int) SvIV(ST(7));
        arg9 = (int) SvIV(ST(8));
        arg10 = (int) SvIV(ST(9));
        arg11 = (int) SvIV(ST(10));
        arg12 = (int) SvIV(ST(11));
        arg13 = (int) SvIV(ST(12));
        arg14 = (int) SvIV(ST(13));
        arg15 = (int) SvIV(ST(14));
        result = (alifegames::Tunneler *)new alifegames::Tunneler(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__Tunneler, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Tunneler_FrontFree) {
    {
        alifegames::Tunneler *arg1 = (alifegames::Tunneler *) 0 ;
        alifegames::IntCoordinate arg2 ;
        alifegames::IntCoordinate arg3 ;
        int *arg4 = 0 ;
        int *arg5 = 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: Tunneler_FrontFree(self,Position,Heading,leftFree,rightFree);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Tunneler,0) < 0) {
                SWIG_croak("Type error in argument 1 of Tunneler_FrontFree. Expected _p_alifegames__Tunneler");
            }
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of Tunneler_FrontFree. Expected _p_alifegames__IntCoordinate");
            }
            arg2 = *argp;
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 3 of Tunneler_FrontFree. Expected _p_alifegames__IntCoordinate");
            }
            arg3 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 4 of Tunneler_FrontFree. Expected _p_int");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 5 of Tunneler_FrontFree. Expected _p_int");
            }
        }
        result = (int)(arg1)->FrontFree(arg2,arg3,*arg4,*arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Tunneler_StepAhead) {
    {
        alifegames::Tunneler *arg1 = (alifegames::Tunneler *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Tunneler_StepAhead(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Tunneler,0) < 0) {
                SWIG_croak("Type error in argument 1 of Tunneler_StepAhead. Expected _p_alifegames__Tunneler");
            }
        }
        result = (bool)(arg1)->StepAhead();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_Roomie) {
    {
        alifegames::Roomie *arg1 = (alifegames::Roomie *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_Roomie(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Roomie,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_Roomie. Expected _p_alifegames__Roomie");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_Roomie) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::IntCoordinate arg2 ;
        alifegames::IntCoordinate arg3 ;
        int arg4 ;
        int arg5 ;
        int arg6 ;
        int arg7 ;
        alifegames::RoomSize arg8 ;
        int arg9 ;
        alifegames::Roomie *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 9) || (items > 9)) {
            SWIG_croak("Usage: new_Roomie(pdm,loc,fwd,a,mA,g,dW,s,cat);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_Roomie. Expected _p_alifegames__DungeonMaker");
            }
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of new_Roomie. Expected _p_alifegames__IntCoordinate");
            }
            arg2 = *argp;
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 3 of new_Roomie. Expected _p_alifegames__IntCoordinate");
            }
            arg3 = *argp;
        }
        arg4 = (int) SvIV(ST(3));
        arg5 = (int) SvIV(ST(4));
        arg6 = (int) SvIV(ST(5));
        arg7 = (int) SvIV(ST(6));
        arg8 = (alifegames::RoomSize) SvIV(ST(7));
        arg9 = (int) SvIV(ST(8));
        result = (alifegames::Roomie *)new alifegames::Roomie(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__Roomie, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Roomie_StepAhead) {
    {
        alifegames::Roomie *arg1 = (alifegames::Roomie *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: Roomie_StepAhead(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Roomie,0) < 0) {
                SWIG_croak("Type error in argument 1 of Roomie_StepAhead. Expected _p_alifegames__Roomie");
            }
        }
        result = (bool)(arg1)->StepAhead();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_Roomie_FrontFree) {
    {
        alifegames::Roomie *arg1 = (alifegames::Roomie *) 0 ;
        alifegames::IntCoordinate arg2 ;
        alifegames::IntCoordinate arg3 ;
        int *arg4 = 0 ;
        int *arg5 = 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: Roomie_FrontFree(self,Position,Heading,leftFree,rightFree);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Roomie,0) < 0) {
                SWIG_croak("Type error in argument 1 of Roomie_FrontFree. Expected _p_alifegames__Roomie");
            }
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of Roomie_FrontFree. Expected _p_alifegames__IntCoordinate");
            }
            arg2 = *argp;
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 3 of Roomie_FrontFree. Expected _p_alifegames__IntCoordinate");
            }
            arg3 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 4 of Roomie_FrontFree. Expected _p_int");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 5 of Roomie_FrontFree. Expected _p_int");
            }
        }
        result = (int)(arg1)->FrontFree(arg2,arg3,*arg4,*arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_new_DungeonMaker) {
    {
        alifegames::Config *arg1 = 0 ;
        unsigned int arg2 ;
        alifegames::DungeonMaker *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: new_DungeonMaker(config,seed);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__Config,0) < 0) {
                SWIG_croak("Type error in argument 1 of new_DungeonMaker. Expected _p_alifegames__Config");
            }
        }
        arg2 = (unsigned int) SvUV(ST(1));
        result = (alifegames::DungeonMaker *)new alifegames::DungeonMaker((alifegames::Config const &)*arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_alifegames__DungeonMaker, SWIG_SHADOW|SWIG_OWNER);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_generate) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_generate(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_generate. Expected _p_alifegames__DungeonMaker");
            }
        }
        (arg1)->generate();
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_SetMap__SWIG_0) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int arg2 ;
        int arg3 ;
        alifegames::SquareData arg4 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: DungeonMaker_SetMap(self,x,y,dat);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_SetMap. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (int) SvIV(ST(1));
        arg3 = (int) SvIV(ST(2));
        arg4 = (alifegames::SquareData) SvIV(ST(3));
        (arg1)->SetMap(arg2,arg3,arg4);
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_SetMap__SWIG_1) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::IntCoordinate arg2 ;
        alifegames::SquareData arg3 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: DungeonMaker_SetMap(self,pos,dat);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_SetMap. Expected _p_alifegames__DungeonMaker");
            }
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of DungeonMaker_SetMap. Expected _p_alifegames__IntCoordinate");
            }
            arg2 = *argp;
        }
        arg3 = (alifegames::SquareData) SvIV(ST(2));
        (arg1)->SetMap(arg2,arg3);
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_SetMap) {
    dXSARGS;
    
    if (items == 3) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_alifegames__DungeonMaker, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_alifegames__IntCoordinate, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    _v = SvIOK(ST(2)) ? 1 : 0;
                }
                if (_v) {
                    (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_DungeonMaker_SetMap__SWIG_1); return;
                }
            }
        }
    }
    if (items == 4) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_alifegames__DungeonMaker, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = SvIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = SvIOK(ST(2)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = SvIOK(ST(3)) ? 1 : 0;
                    }
                    if (_v) {
                        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_DungeonMaker_SetMap__SWIG_0); return;
                    }
                }
            }
        }
    }
    
    croak("No matching function for overloaded 'DungeonMaker_SetMap'");
    XSRETURN(0);
}


XS(_wrap_DungeonMaker_GetMap__SWIG_0) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int arg2 ;
        int arg3 ;
        alifegames::SquareData result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: DungeonMaker_GetMap(self,x,y);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetMap. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (int) SvIV(ST(1));
        arg3 = (int) SvIV(ST(2));
        result = (alifegames::SquareData)(arg1)->GetMap(arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetMap__SWIG_1) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::IntCoordinate arg2 ;
        alifegames::SquareData result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_GetMap(self,pos);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetMap. Expected _p_alifegames__DungeonMaker");
            }
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of DungeonMaker_GetMap. Expected _p_alifegames__IntCoordinate");
            }
            arg2 = *argp;
        }
        result = (alifegames::SquareData)(arg1)->GetMap(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetMap) {
    dXSARGS;
    
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_alifegames__DungeonMaker, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_alifegames__IntCoordinate, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_DungeonMaker_GetMap__SWIG_1); return;
            }
        }
    }
    if (items == 3) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_alifegames__DungeonMaker, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = SvIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = SvIOK(ST(2)) ? 1 : 0;
                }
                if (_v) {
                    (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_DungeonMaker_GetMap__SWIG_0); return;
                }
            }
        }
    }
    
    croak("No matching function for overloaded 'DungeonMaker_GetMap'");
    XSRETURN(0);
}


XS(_wrap_DungeonMaker_SetRect__SWIG_0) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int arg2 ;
        int arg3 ;
        int arg4 ;
        int arg5 ;
        alifegames::SquareData arg6 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 6) || (items > 6)) {
            SWIG_croak("Usage: DungeonMaker_SetRect(self,startX,startY,endX,endY,dat);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_SetRect. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (int) SvIV(ST(1));
        arg3 = (int) SvIV(ST(2));
        arg4 = (int) SvIV(ST(3));
        arg5 = (int) SvIV(ST(4));
        arg6 = (alifegames::SquareData) SvIV(ST(5));
        (arg1)->SetRect(arg2,arg3,arg4,arg5,arg6);
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_SetRect__SWIG_1) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        SwigValueWrapper<alifegames::RectFill > arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_SetRect(self,rectDat);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_SetRect. Expected _p_alifegames__DungeonMaker");
            }
        }
        {
            alifegames::RectFill * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__RectFill,0) < 0) {
                SWIG_croak("Type error in argument 2 of DungeonMaker_SetRect. Expected _p_alifegames__RectFill");
            }
            arg2 = *argp;
        }
        (arg1)->SetRect(arg2);
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_SetRect) {
    dXSARGS;
    
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_alifegames__DungeonMaker, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *tmp;
                if (SWIG_ConvertPtr(ST(1), (void **) &tmp, SWIGTYPE_p_alifegames__RectFill, 0) == -1) {
                    _v = 0;
                } else {
                    _v = 1;
                }
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_DungeonMaker_SetRect__SWIG_1); return;
            }
        }
    }
    if (items == 6) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_alifegames__DungeonMaker, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = SvIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = SvIOK(ST(2)) ? 1 : 0;
                }
                if (_v) {
                    {
                        _v = SvIOK(ST(3)) ? 1 : 0;
                    }
                    if (_v) {
                        {
                            _v = SvIOK(ST(4)) ? 1 : 0;
                        }
                        if (_v) {
                            {
                                _v = SvIOK(ST(5)) ? 1 : 0;
                            }
                            if (_v) {
                                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_DungeonMaker_SetRect__SWIG_0); return;
                            }
                        }
                    }
                }
            }
        }
    }
    
    croak("No matching function for overloaded 'DungeonMaker_SetRect'");
    XSRETURN(0);
}


XS(_wrap_DungeonMaker_GetDimX) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetDimX(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetDimX. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetDimX();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetDimY) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetDimY(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetDimY. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetDimY();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetActiveGeneration) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetActiveGeneration(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetActiveGeneration. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetActiveGeneration();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetMinRoomSize) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::RoomSize arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_GetMinRoomSize(self,sz);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetMinRoomSize. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (alifegames::RoomSize) SvIV(ST(1));
        result = (int)(arg1)->GetMinRoomSize(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetMaxRoomSize) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::RoomSize arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_GetMaxRoomSize(self,sz);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetMaxRoomSize. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (alifegames::RoomSize) SvIV(ST(1));
        result = (int)(arg1)->GetMaxRoomSize(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetBackground) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::SquareData result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetBackground(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetBackground. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (alifegames::SquareData)(arg1)->GetBackground();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetMovie) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        SwigValueWrapper<std::vector<std::vector<alifegames::SquareInfo > > > result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetMovie(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetMovie. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (arg1)->GetMovie();
        
        {
            std::vector<std::vector<alifegames::SquareInfo > > * resultobj = new std::vector<std::vector<alifegames::SquareInfo > >((std::vector<std::vector<alifegames::SquareInfo > > &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_std__vectorTstd__vectorTalifegames__SquareInfo_t_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_ShowMovie) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_ShowMovie(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_ShowMovie. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (bool)(arg1)->ShowMovie();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_StoreMovie) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_StoreMovie(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_StoreMovie. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (bool)(arg1)->StoreMovie();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetDesign) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        SwigValueWrapper<std::vector<alifegames::RectFill > > result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetDesign(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetDesign. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (arg1)->GetDesign();
        
        {
            std::vector<alifegames::RectFill > * resultobj = new std::vector<alifegames::RectFill >((std::vector<alifegames::RectFill > &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_std__vectorTalifegames__RectFill_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetRooms) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        SwigValueWrapper<std::vector<alifegames::Room > > result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetRooms(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetRooms. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (arg1)->GetRooms();
        
        {
            std::vector<alifegames::Room > * resultobj = new std::vector<alifegames::Room >((std::vector<alifegames::Room > &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_std__vectorTalifegames__Room_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetMOBs) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        SwigValueWrapper<std::vector<alifegames::SpawnInfo > > result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetMOBs(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetMOBs. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (arg1)->GetMOBs();
        
        {
            std::vector<alifegames::SpawnInfo > * resultobj = new std::vector<alifegames::SpawnInfo >((std::vector<alifegames::SpawnInfo > &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_std__vectorTalifegames__SpawnInfo_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetTreas) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        SwigValueWrapper<std::vector<alifegames::SpawnInfo > > result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetTreas(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetTreas. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (arg1)->GetTreas();
        
        {
            std::vector<alifegames::SpawnInfo > * resultobj = new std::vector<alifegames::SpawnInfo >((std::vector<alifegames::SpawnInfo > &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_std__vectorTalifegames__SpawnInfo_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetRoomSizeProbS) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        unsigned int arg2 ;
        alifegames::RoomSize arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: DungeonMaker_GetRoomSizeProbS(self,tW,sz);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetRoomSizeProbS. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (unsigned int) SvUV(ST(1));
        arg3 = (alifegames::RoomSize) SvIV(ST(2));
        result = (int)(arg1)->GetRoomSizeProbS(arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetRoomSizeProbB) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        unsigned int arg2 ;
        alifegames::RoomSize arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: DungeonMaker_GetRoomSizeProbB(self,tW,sz);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetRoomSizeProbB. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (unsigned int) SvUV(ST(1));
        arg3 = (alifegames::RoomSize) SvIV(ST(2));
        result = (int)(arg1)->GetRoomSizeProbB(arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_WantsMoreRoomsL__SWIG_0) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::RoomSize arg2 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_WantsMoreRoomsL(self,sz);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_WantsMoreRoomsL. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (alifegames::RoomSize) SvIV(ST(1));
        result = (bool)(arg1)->WantsMoreRoomsL(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_WantsMoreRoomsL__SWIG_1) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_WantsMoreRoomsL(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_WantsMoreRoomsL. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (bool)(arg1)->WantsMoreRoomsL();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_WantsMoreRoomsL) {
    dXSARGS;
    
    if (items == 1) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_alifegames__DungeonMaker, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_DungeonMaker_WantsMoreRoomsL__SWIG_1); return;
        }
    }
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_alifegames__DungeonMaker, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = SvIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_DungeonMaker_WantsMoreRoomsL__SWIG_0); return;
            }
        }
    }
    
    croak("No matching function for overloaded 'DungeonMaker_WantsMoreRoomsL'");
    XSRETURN(0);
}


XS(_wrap_DungeonMaker_WantsMoreRoomsD__SWIG_0) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::RoomSize arg2 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_WantsMoreRoomsD(self,sz);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_WantsMoreRoomsD. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (alifegames::RoomSize) SvIV(ST(1));
        result = (bool)(arg1)->WantsMoreRoomsD(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_WantsMoreRoomsD__SWIG_1) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_WantsMoreRoomsD(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_WantsMoreRoomsD. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (bool)(arg1)->WantsMoreRoomsD();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_WantsMoreRoomsD) {
    dXSARGS;
    
    if (items == 1) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_alifegames__DungeonMaker, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_DungeonMaker_WantsMoreRoomsD__SWIG_1); return;
        }
    }
    if (items == 2) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_alifegames__DungeonMaker, 0) == -1) {
                _v = 0;
            } else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = SvIOK(ST(1)) ? 1 : 0;
            }
            if (_v) {
                (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_DungeonMaker_WantsMoreRoomsD__SWIG_0); return;
            }
        }
    }
    
    croak("No matching function for overloaded 'DungeonMaker_WantsMoreRoomsD'");
    XSRETURN(0);
}


XS(_wrap_DungeonMaker_BuiltRoomD) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::RoomSize arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_BuiltRoomD(self,sz);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_BuiltRoomD. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (alifegames::RoomSize) SvIV(ST(1));
        (arg1)->BuiltRoomD(arg2);
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_SortRooms) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_SortRooms(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_SortRooms. Expected _p_alifegames__DungeonMaker");
            }
        }
        (arg1)->SortRooms();
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetChangedThisIteration) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        SwigValueWrapper<std::vector<alifegames::SquareInfo > > result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetChangedThisIteration(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetChangedThisIteration. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (arg1)->GetChangedThisIteration();
        
        {
            std::vector<alifegames::SquareInfo > * resultobj = new std::vector<alifegames::SquareInfo >((std::vector<alifegames::SquareInfo > &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_std__vectorTalifegames__SquareInfo_t, 0|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetBabyDelayProbsForGenerationC) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_GetBabyDelayProbsForGenerationC(self,gen);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetBabyDelayProbsForGenerationC. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (int) SvIV(ST(1));
        result = (int)(arg1)->GetBabyDelayProbsForGenerationC(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetBabyDelayProbsForGenerationR) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_GetBabyDelayProbsForGenerationR(self,gen);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetBabyDelayProbsForGenerationR. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (int) SvIV(ST(1));
        result = (int)(arg1)->GetBabyDelayProbsForGenerationR(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetBabyDelayProbsForGenerationT) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_GetBabyDelayProbsForGenerationT(self,gen);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetBabyDelayProbsForGenerationT. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (int) SvIV(ST(1));
        result = (int)(arg1)->GetBabyDelayProbsForGenerationT(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetGenSpeeUpOnAnteRoom) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetGenSpeeUpOnAnteRoom(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetGenSpeeUpOnAnteRoom. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetGenSpeeUpOnAnteRoom();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_Mutate) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_Mutate(self,input);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_Mutate. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (int) SvIV(ST(1));
        result = (int)(arg1)->Mutate(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_Mutate2) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_Mutate2(self,input);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_Mutate2. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (int) SvIV(ST(1));
        result = (int)(arg1)->Mutate2(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetNoHeadingProb) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetNoHeadingProb(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetNoHeadingProb. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetNoHeadingProb();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetStepLength) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        unsigned int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_GetStepLength(self,g);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetStepLength. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (unsigned int) SvUV(ST(1));
        result = (int)(arg1)->GetStepLength(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetCorrWidth) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        unsigned int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_GetCorrWidth(self,g);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetCorrWidth. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (unsigned int) SvUV(ST(1));
        result = (int)(arg1)->GetCorrWidth(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetMaxAgeC) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        unsigned int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_GetMaxAgeC(self,g);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetMaxAgeC. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (unsigned int) SvUV(ST(1));
        result = (int)(arg1)->GetMaxAgeC(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetMaxAgeT) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        unsigned int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_GetMaxAgeT(self,g);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetMaxAgeT. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (unsigned int) SvUV(ST(1));
        result = (int)(arg1)->GetMaxAgeT(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetAnteRoomProb) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        unsigned int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_GetAnteRoomProb(self,tW);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetAnteRoomProb. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (unsigned int) SvUV(ST(1));
        result = (int)(arg1)->GetAnteRoomProb(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetJoinDist) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetJoinDist(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetJoinDist. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetJoinDist();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetSizeUpGenDelay) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetSizeUpGenDelay(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetSizeUpGenDelay. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetSizeUpGenDelay();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetTunnelJoinDist) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetTunnelJoinDist(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetTunnelJoinDist. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetTunnelJoinDist();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_CreateCrawler) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::IntCoordinate arg2 ;
        alifegames::IntCoordinate arg3 ;
        int arg4 ;
        int arg5 ;
        int arg6 ;
        alifegames::IntCoordinate arg7 ;
        int arg8 ;
        int arg9 ;
        int arg10 ;
        int arg11 ;
        int arg12 ;
        int arg13 ;
        int arg14 ;
        int arg15 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 15) || (items > 15)) {
            SWIG_croak("Usage: DungeonMaker_CreateCrawler(self,loc,fwd,a,mA,g,intDir,sL,o,cW,sSSP,sDSP,tSSP,tDSP,cDP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_CreateCrawler. Expected _p_alifegames__DungeonMaker");
            }
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of DungeonMaker_CreateCrawler. Expected _p_alifegames__IntCoordinate");
            }
            arg2 = *argp;
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 3 of DungeonMaker_CreateCrawler. Expected _p_alifegames__IntCoordinate");
            }
            arg3 = *argp;
        }
        arg4 = (int) SvIV(ST(3));
        arg5 = (int) SvIV(ST(4));
        arg6 = (int) SvIV(ST(5));
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(6),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 7 of DungeonMaker_CreateCrawler. Expected _p_alifegames__IntCoordinate");
            }
            arg7 = *argp;
        }
        arg8 = (int) SvIV(ST(7));
        arg9 = (int) SvIV(ST(8));
        arg10 = (int) SvIV(ST(9));
        arg11 = (int) SvIV(ST(10));
        arg12 = (int) SvIV(ST(11));
        arg13 = (int) SvIV(ST(12));
        arg14 = (int) SvIV(ST(13));
        arg15 = (int) SvIV(ST(14));
        (arg1)->CreateCrawler(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15);
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_CreateTunneler) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::IntCoordinate arg2 ;
        alifegames::IntCoordinate arg3 ;
        int arg4 ;
        int arg5 ;
        int arg6 ;
        alifegames::IntCoordinate arg7 ;
        int arg8 ;
        int arg9 ;
        int arg10 ;
        int arg11 ;
        int arg12 ;
        int arg13 ;
        int arg14 ;
        int arg15 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 15) || (items > 15)) {
            SWIG_croak("Usage: DungeonMaker_CreateTunneler(self,loc,fwd,a,mA,g,intDir,sL,tW,sDSP,tDSP,cDP,mRRP,mRLP,jP);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_CreateTunneler. Expected _p_alifegames__DungeonMaker");
            }
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of DungeonMaker_CreateTunneler. Expected _p_alifegames__IntCoordinate");
            }
            arg2 = *argp;
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 3 of DungeonMaker_CreateTunneler. Expected _p_alifegames__IntCoordinate");
            }
            arg3 = *argp;
        }
        arg4 = (int) SvIV(ST(3));
        arg5 = (int) SvIV(ST(4));
        arg6 = (int) SvIV(ST(5));
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(6),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 7 of DungeonMaker_CreateTunneler. Expected _p_alifegames__IntCoordinate");
            }
            arg7 = *argp;
        }
        arg8 = (int) SvIV(ST(7));
        arg9 = (int) SvIV(ST(8));
        arg10 = (int) SvIV(ST(9));
        arg11 = (int) SvIV(ST(10));
        arg12 = (int) SvIV(ST(11));
        arg13 = (int) SvIV(ST(12));
        arg14 = (int) SvIV(ST(13));
        arg15 = (int) SvIV(ST(14));
        (arg1)->CreateTunneler(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15);
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_CreateRoomie) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::IntCoordinate arg2 ;
        alifegames::IntCoordinate arg3 ;
        int arg4 ;
        int arg5 ;
        int arg6 ;
        int arg7 ;
        alifegames::RoomSize arg8 ;
        int arg9 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 9) || (items > 9)) {
            SWIG_croak("Usage: DungeonMaker_CreateRoomie(self,loc,fwd,a,mA,g,dW,s,cat);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_CreateRoomie. Expected _p_alifegames__DungeonMaker");
            }
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of DungeonMaker_CreateRoomie. Expected _p_alifegames__IntCoordinate");
            }
            arg2 = *argp;
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 3 of DungeonMaker_CreateRoomie. Expected _p_alifegames__IntCoordinate");
            }
            arg3 = *argp;
        }
        arg4 = (int) SvIV(ST(3));
        arg5 = (int) SvIV(ST(4));
        arg6 = (int) SvIV(ST(5));
        arg7 = (int) SvIV(ST(6));
        arg8 = (alifegames::RoomSize) SvIV(ST(7));
        arg9 = (int) SvIV(ST(8));
        (arg1)->CreateRoomie(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_MakeIteration) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_MakeIteration(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_MakeIteration. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (bool)(arg1)->MakeIteration();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_AdvanceGeneration) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_AdvanceGeneration(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_AdvanceGeneration. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (bool)(arg1)->AdvanceGeneration();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_CreateRoom) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        SwigValueWrapper<alifegames::RectFill > arg2 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_CreateRoom(self,rect);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_CreateRoom. Expected _p_alifegames__DungeonMaker");
            }
        }
        {
            alifegames::RectFill * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__RectFill,0) < 0) {
                SWIG_croak("Type error in argument 2 of DungeonMaker_CreateRoom. Expected _p_alifegames__RectFill");
            }
            arg2 = *argp;
        }
        result = (bool)(arg1)->CreateRoom(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetJoinPref) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        unsigned int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_GetJoinPref(self,g);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetJoinPref. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (unsigned int) SvUV(ST(1));
        result = (int)(arg1)->GetJoinPref(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetSizeUpProb) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        unsigned int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_GetSizeUpProb(self,g);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetSizeUpProb. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (unsigned int) SvUV(ST(1));
        result = (int)(arg1)->GetSizeUpProb(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetSizeDownProb) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        unsigned int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_GetSizeDownProb(self,g);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetSizeDownProb. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (unsigned int) SvUV(ST(1));
        result = (int)(arg1)->GetSizeDownProb(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetPatience) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetPatience(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetPatience. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetPatience();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetRoomAspectRatio) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        double result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetRoomAspectRatio(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetRoomAspectRatio. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (double)(arg1)->GetRoomAspectRatio();
        
        ST(argvi) = sv_newmortal();
        sv_setnv(ST(argvi++), (double) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_WeWantColumnsInTunnels) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_WeWantColumnsInTunnels(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_WeWantColumnsInTunnels. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (bool)(arg1)->WeWantColumnsInTunnels();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_CrawlersInTunnels) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_CrawlersInTunnels(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_CrawlersInTunnels. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (bool)(arg1)->CrawlersInTunnels();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_CrawlersInAnterooms) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_CrawlersInAnterooms(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_CrawlersInAnterooms. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (bool)(arg1)->CrawlersInAnterooms();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_SeedCrawlersInTunnels) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_SeedCrawlersInTunnels(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_SeedCrawlersInTunnels. Expected _p_alifegames__DungeonMaker");
            }
        }
        (arg1)->SeedCrawlersInTunnels();
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetTunnelCrawlerGeneration) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetTunnelCrawlerGeneration(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetTunnelCrawlerGeneration. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetTunnelCrawlerGeneration();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetLastChanceRoomsRightProb) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetLastChanceRoomsRightProb(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetLastChanceRoomsRightProb. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetLastChanceRoomsRightProb();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetLastChanceRoomsLeftProb) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetLastChanceRoomsLeftProb(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetLastChanceRoomsLeftProb. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetLastChanceRoomsLeftProb();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetLastChanceChangeDirProb) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetLastChanceChangeDirProb(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetLastChanceChangeDirProb. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetLastChanceChangeDirProb();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetLastChanceStraightSpawnProb) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetLastChanceStraightSpawnProb(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetLastChanceStraightSpawnProb. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetLastChanceStraightSpawnProb();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetLastChanceTurnSpawnProb) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetLastChanceTurnSpawnProb(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetLastChanceTurnSpawnProb. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetLastChanceTurnSpawnProb();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_GetLastChanceGenDelay) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_GetLastChanceGenDelay(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_GetLastChanceGenDelay. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (int)(arg1)->GetLastChanceGenDelay();
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_AddRoom) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::Room arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_AddRoom(self,r);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_AddRoom. Expected _p_alifegames__DungeonMaker");
            }
        }
        {
            alifegames::Room * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__Room,0) < 0) {
                SWIG_croak("Type error in argument 2 of DungeonMaker_AddRoom. Expected _p_alifegames__Room");
            }
            arg2 = *argp;
        }
        (arg1)->AddRoom(arg2);
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_NumberOfRooms) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        unsigned int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_NumberOfRooms(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_NumberOfRooms. Expected _p_alifegames__DungeonMaker");
            }
        }
        result = (unsigned int)(arg1)->NumberOfRooms();
        
        ST(argvi) = sv_newmortal();
        sv_setuv(ST(argvi++), (UV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_RoomNumber) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        unsigned int arg2 ;
        alifegames::Room result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_RoomNumber(self,i);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_RoomNumber. Expected _p_alifegames__DungeonMaker");
            }
        }
        arg2 = (unsigned int) SvUV(ST(1));
        result = (arg1)->RoomNumber(arg2);
        
        {
            alifegames::Room * resultobj = new alifegames::Room((alifegames::Room &)result);
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_alifegames__Room, SWIG_SHADOW|SWIG_OWNER);
        }
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_PlonkDownStuff) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_PlonkDownStuff(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_PlonkDownStuff. Expected _p_alifegames__DungeonMaker");
            }
        }
        (arg1)->PlonkDownStuff();
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_PutPlonkOnMap) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: DungeonMaker_PutPlonkOnMap(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_PutPlonkOnMap. Expected _p_alifegames__DungeonMaker");
            }
        }
        (arg1)->PutPlonkOnMap();
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_IsChecked) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::IntCoordinate arg2 ;
        bool result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_IsChecked(self,pos);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_IsChecked. Expected _p_alifegames__DungeonMaker");
            }
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of DungeonMaker_IsChecked. Expected _p_alifegames__IntCoordinate");
            }
            arg2 = *argp;
        }
        result = (bool)(arg1)->IsChecked(arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_SetChecked) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::IntCoordinate arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_SetChecked(self,pos);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_SetChecked. Expected _p_alifegames__DungeonMaker");
            }
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of DungeonMaker_SetChecked. Expected _p_alifegames__IntCoordinate");
            }
            arg2 = *argp;
        }
        (arg1)->SetChecked(arg2);
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_DungeonMaker_SetUnchecked) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        alifegames::IntCoordinate arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: DungeonMaker_SetUnchecked(self,pos);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of DungeonMaker_SetUnchecked. Expected _p_alifegames__DungeonMaker");
            }
        }
        {
            alifegames::IntCoordinate * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_alifegames__IntCoordinate,0) < 0) {
                SWIG_croak("Type error in argument 2 of DungeonMaker_SetUnchecked. Expected _p_alifegames__IntCoordinate");
            }
            arg2 = *argp;
        }
        (arg1)->SetUnchecked(arg2);
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}


XS(_wrap_delete_DungeonMaker) {
    {
        alifegames::DungeonMaker *arg1 = (alifegames::DungeonMaker *) 0 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_DungeonMaker(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_alifegames__DungeonMaker,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_DungeonMaker. Expected _p_alifegames__DungeonMaker");
            }
        }
        delete arg1;
        
        
        XSRETURN(argvi);
        fail:
        ;
    }
    croak(Nullch);
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_alifegames__IntCoordinateTo_p_std__pairTint_int_t(void *x) {
    return (void *)((std::pair<int,int > *)  ((alifegames::IntCoordinate *) x));
}
static void *_p_alifegames__RoomieTo_p_alifegames__Builder(void *x) {
    return (void *)((alifegames::Builder *)  ((alifegames::Roomie *) x));
}
static void *_p_alifegames__TunnelerTo_p_alifegames__Builder(void *x) {
    return (void *)((alifegames::Builder *)  ((alifegames::Tunneler *) x));
}
static void *_p_alifegames__WallCrawlerTo_p_alifegames__Builder(void *x) {
    return (void *)((alifegames::Builder *)  ((alifegames::WallCrawler *) x));
}
static swig_type_info _swigt__p_alifegames__Builder = {"Games::DungeonMaker::Builder", "alifegames::Builder *", 0, 0, 0};
static swig_type_info _swigt__p_alifegames__Config = {"Games::DungeonMaker::Config", "alifegames::Config *", 0, 0, 0};
static swig_type_info _swigt__p_alifegames__CrawlerData = {"Games::DungeonMaker::CrawlerData", "alifegames::CrawlerData *", 0, 0, 0};
static swig_type_info _swigt__p_alifegames__DungeonMaker = {"Games::DungeonMaker::DungeonMaker", "alifegames::DungeonMaker *", 0, 0, 0};
static swig_type_info _swigt__p_alifegames__FlagsDirs = {"Games::DungeonMaker::FlagsDirs", "alifegames::FlagsDirs *", 0, 0, 0};
static swig_type_info _swigt__p_alifegames__IntCoordinate = {"Games::DungeonMaker::IntCoordinate", "alifegames::IntCoordinate *", 0, 0, 0};
static swig_type_info _swigt__p_alifegames__RectFill = {"Games::DungeonMaker::RectFill", "alifegames::RectFill *", 0, 0, 0};
static swig_type_info _swigt__p_alifegames__Room = {"Games::DungeonMaker::Room", "alifegames::Room *", 0, 0, 0};
static swig_type_info _swigt__p_alifegames__RoomComp = {"Games::DungeonMaker::RoomComp", "alifegames::RoomComp *", 0, 0, 0};
static swig_type_info _swigt__p_alifegames__Roomie = {"Games::DungeonMaker::Roomie", "alifegames::Roomie *", 0, 0, 0};
static swig_type_info _swigt__p_alifegames__SpawnInfo = {"Games::DungeonMaker::SpawnInfo", "alifegames::SpawnInfo *", 0, 0, 0};
static swig_type_info _swigt__p_alifegames__SquareInfo = {"Games::DungeonMaker::SquareInfo", "alifegames::SquareInfo *", 0, 0, 0};
static swig_type_info _swigt__p_alifegames__TripleInt = {"Games::DungeonMaker::TripleInt", "alifegames::TripleInt *", 0, 0, 0};
static swig_type_info _swigt__p_alifegames__Tunneler = {"Games::DungeonMaker::Tunneler", "alifegames::Tunneler *", 0, 0, 0};
static swig_type_info _swigt__p_alifegames__TunnelerData = {"Games::DungeonMaker::TunnelerData", "alifegames::TunnelerData *", 0, 0, 0};
static swig_type_info _swigt__p_alifegames__WallCrawler = {"Games::DungeonMaker::WallCrawler", "alifegames::WallCrawler *", 0, 0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, 0};
static swig_type_info _swigt__p_std__pairTint_int_t = {"Games::DungeonMaker::pair_ii", "std::pair<int,int > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTalifegames__CrawlerData_t = {"_p_std__vectorTalifegames__CrawlerData_t", "std::vector<alifegames::CrawlerData > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTalifegames__Direction_t = {"_p_std__vectorTalifegames__Direction_t", "std::vector<enum alifegames::Direction > *|std::vector<alifegames::Direction > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTalifegames__IntCoordinate_t = {"_p_std__vectorTalifegames__IntCoordinate_t", "std::vector<alifegames::IntCoordinate > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTalifegames__RectFill_t = {"_p_std__vectorTalifegames__RectFill_t", "std::vector<alifegames::RectFill > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTalifegames__Room_t = {"_p_std__vectorTalifegames__Room_t", "std::vector<alifegames::Room > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTalifegames__SpawnInfo_t = {"_p_std__vectorTalifegames__SpawnInfo_t", "std::vector<alifegames::SpawnInfo > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTalifegames__SquareInfo_t = {"_p_std__vectorTalifegames__SquareInfo_t", "std::vector<alifegames::SquareInfo > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTalifegames__TripleInt_t = {"_p_std__vectorTalifegames__TripleInt_t", "std::vector<alifegames::TripleInt > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTalifegames__TunnelerData_t = {"_p_std__vectorTalifegames__TunnelerData_t", "std::vector<alifegames::TunnelerData > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTint_t = {"_p_std__vectorTint_t", "std::vector<int > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTstd__pairTalifegames__CrawlerData_alifegames__CrawlerData_t_t = {"_p_std__vectorTstd__pairTalifegames__CrawlerData_alifegames__CrawlerData_t_t", "std::vector<std::pair<alifegames::CrawlerData,alifegames::CrawlerData > > *", 0, 0, 0};
static swig_type_info _swigt__p_std__vectorTstd__vectorTalifegames__SquareInfo_t_t = {"_p_std__vectorTstd__vectorTalifegames__SquareInfo_t_t", "std::vector<std::vector<alifegames::SquareInfo > > *", 0, 0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_alifegames__Builder,
  &_swigt__p_alifegames__Config,
  &_swigt__p_alifegames__CrawlerData,
  &_swigt__p_alifegames__DungeonMaker,
  &_swigt__p_alifegames__FlagsDirs,
  &_swigt__p_alifegames__IntCoordinate,
  &_swigt__p_alifegames__RectFill,
  &_swigt__p_alifegames__Room,
  &_swigt__p_alifegames__RoomComp,
  &_swigt__p_alifegames__Roomie,
  &_swigt__p_alifegames__SpawnInfo,
  &_swigt__p_alifegames__SquareInfo,
  &_swigt__p_alifegames__TripleInt,
  &_swigt__p_alifegames__Tunneler,
  &_swigt__p_alifegames__TunnelerData,
  &_swigt__p_alifegames__WallCrawler,
  &_swigt__p_int,
  &_swigt__p_std__pairTint_int_t,
  &_swigt__p_std__vectorTalifegames__CrawlerData_t,
  &_swigt__p_std__vectorTalifegames__Direction_t,
  &_swigt__p_std__vectorTalifegames__IntCoordinate_t,
  &_swigt__p_std__vectorTalifegames__RectFill_t,
  &_swigt__p_std__vectorTalifegames__Room_t,
  &_swigt__p_std__vectorTalifegames__SpawnInfo_t,
  &_swigt__p_std__vectorTalifegames__SquareInfo_t,
  &_swigt__p_std__vectorTalifegames__TripleInt_t,
  &_swigt__p_std__vectorTalifegames__TunnelerData_t,
  &_swigt__p_std__vectorTint_t,
  &_swigt__p_std__vectorTstd__pairTalifegames__CrawlerData_alifegames__CrawlerData_t_t,
  &_swigt__p_std__vectorTstd__vectorTalifegames__SquareInfo_t_t,
};

static swig_cast_info _swigc__p_alifegames__Builder[] = {  {&_swigt__p_alifegames__Builder, 0, 0, 0},  {&_swigt__p_alifegames__Roomie, _p_alifegames__RoomieTo_p_alifegames__Builder, 0, 0},  {&_swigt__p_alifegames__Tunneler, _p_alifegames__TunnelerTo_p_alifegames__Builder, 0, 0},  {&_swigt__p_alifegames__WallCrawler, _p_alifegames__WallCrawlerTo_p_alifegames__Builder, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alifegames__Config[] = {  {&_swigt__p_alifegames__Config, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alifegames__CrawlerData[] = {  {&_swigt__p_alifegames__CrawlerData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alifegames__DungeonMaker[] = {  {&_swigt__p_alifegames__DungeonMaker, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alifegames__FlagsDirs[] = {  {&_swigt__p_alifegames__FlagsDirs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alifegames__IntCoordinate[] = {  {&_swigt__p_alifegames__IntCoordinate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alifegames__RectFill[] = {  {&_swigt__p_alifegames__RectFill, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alifegames__Room[] = {  {&_swigt__p_alifegames__Room, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alifegames__RoomComp[] = {  {&_swigt__p_alifegames__RoomComp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alifegames__Roomie[] = {  {&_swigt__p_alifegames__Roomie, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alifegames__SpawnInfo[] = {  {&_swigt__p_alifegames__SpawnInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alifegames__SquareInfo[] = {  {&_swigt__p_alifegames__SquareInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alifegames__TripleInt[] = {  {&_swigt__p_alifegames__TripleInt, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alifegames__Tunneler[] = {  {&_swigt__p_alifegames__Tunneler, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alifegames__TunnelerData[] = {  {&_swigt__p_alifegames__TunnelerData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alifegames__WallCrawler[] = {  {&_swigt__p_alifegames__WallCrawler, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairTint_int_t[] = {  {&_swigt__p_alifegames__IntCoordinate, _p_alifegames__IntCoordinateTo_p_std__pairTint_int_t, 0, 0},  {&_swigt__p_std__pairTint_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTalifegames__CrawlerData_t[] = {  {&_swigt__p_std__vectorTalifegames__CrawlerData_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTalifegames__Direction_t[] = {  {&_swigt__p_std__vectorTalifegames__Direction_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTalifegames__IntCoordinate_t[] = {  {&_swigt__p_std__vectorTalifegames__IntCoordinate_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTalifegames__RectFill_t[] = {  {&_swigt__p_std__vectorTalifegames__RectFill_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTalifegames__Room_t[] = {  {&_swigt__p_std__vectorTalifegames__Room_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTalifegames__SpawnInfo_t[] = {  {&_swigt__p_std__vectorTalifegames__SpawnInfo_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTalifegames__SquareInfo_t[] = {  {&_swigt__p_std__vectorTalifegames__SquareInfo_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTalifegames__TripleInt_t[] = {  {&_swigt__p_std__vectorTalifegames__TripleInt_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTalifegames__TunnelerData_t[] = {  {&_swigt__p_std__vectorTalifegames__TunnelerData_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTint_t[] = {  {&_swigt__p_std__vectorTint_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__pairTalifegames__CrawlerData_alifegames__CrawlerData_t_t[] = {  {&_swigt__p_std__vectorTstd__pairTalifegames__CrawlerData_alifegames__CrawlerData_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__vectorTalifegames__SquareInfo_t_t[] = {  {&_swigt__p_std__vectorTstd__vectorTalifegames__SquareInfo_t_t, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_alifegames__Builder,
  _swigc__p_alifegames__Config,
  _swigc__p_alifegames__CrawlerData,
  _swigc__p_alifegames__DungeonMaker,
  _swigc__p_alifegames__FlagsDirs,
  _swigc__p_alifegames__IntCoordinate,
  _swigc__p_alifegames__RectFill,
  _swigc__p_alifegames__Room,
  _swigc__p_alifegames__RoomComp,
  _swigc__p_alifegames__Roomie,
  _swigc__p_alifegames__SpawnInfo,
  _swigc__p_alifegames__SquareInfo,
  _swigc__p_alifegames__TripleInt,
  _swigc__p_alifegames__Tunneler,
  _swigc__p_alifegames__TunnelerData,
  _swigc__p_alifegames__WallCrawler,
  _swigc__p_int,
  _swigc__p_std__pairTint_int_t,
  _swigc__p_std__vectorTalifegames__CrawlerData_t,
  _swigc__p_std__vectorTalifegames__Direction_t,
  _swigc__p_std__vectorTalifegames__IntCoordinate_t,
  _swigc__p_std__vectorTalifegames__RectFill_t,
  _swigc__p_std__vectorTalifegames__Room_t,
  _swigc__p_std__vectorTalifegames__SpawnInfo_t,
  _swigc__p_std__vectorTalifegames__SquareInfo_t,
  _swigc__p_std__vectorTalifegames__TripleInt_t,
  _swigc__p_std__vectorTalifegames__TunnelerData_t,
  _swigc__p_std__vectorTint_t,
  _swigc__p_std__vectorTstd__pairTalifegames__CrawlerData_alifegames__CrawlerData_t_t,
  _swigc__p_std__vectorTstd__vectorTalifegames__SquareInfo_t_t,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_constant_info swig_constants[] = {
{ SWIG_INT,     (char *) SWIG_prefix "DUNGEONMAKER_H_INCLUDED", (long) 1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "OPEN", (long) alifegames::OPEN, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "CLOSED", (long) alifegames::CLOSED, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "G_OPEN", (long) alifegames::G_OPEN, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "G_CLOSED", (long) alifegames::G_CLOSED, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "NJ_OPEN", (long) alifegames::NJ_OPEN, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "NJ_CLOSED", (long) alifegames::NJ_CLOSED, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "NJ_G_OPEN", (long) alifegames::NJ_G_OPEN, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "NJ_G_CLOSED", (long) alifegames::NJ_G_CLOSED, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "IR_OPEN", (long) alifegames::IR_OPEN, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "IT_OPEN", (long) alifegames::IT_OPEN, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "IA_OPEN", (long) alifegames::IA_OPEN, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "H_DOOR", (long) alifegames::H_DOOR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "V_DOOR", (long) alifegames::V_DOOR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "MOB1", (long) alifegames::MOB1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "MOB2", (long) alifegames::MOB2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "MOB3", (long) alifegames::MOB3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "TREAS1", (long) alifegames::TREAS1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "TREAS2", (long) alifegames::TREAS2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "TREAS3", (long) alifegames::TREAS3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "COLUMN", (long) alifegames::COLUMN, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "NO", (long) alifegames::NO, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "EA", (long) alifegames::EA, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "SO", (long) alifegames::SO, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "WE", (long) alifegames::WE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "NE", (long) alifegames::NE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "SE", (long) alifegames::SE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "SW", (long) alifegames::SW, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "NW", (long) alifegames::NW, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XX", (long) alifegames::XX, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "SMALL", (long) alifegames::SMALL, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "MEDIUM", (long) alifegames::MEDIUM, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LARGE", (long) alifegames::LARGE, 0, 0, 0},
{0,0,0,0,0,0}
};
#ifdef __cplusplus
}
#endif
static swig_variable_info swig_variables[] = {
{0,0,0,0}
};
static swig_command_info swig_commands[] = {
{"Games::DungeonMakerc::new_pair_ii", _wrap_new_pair_ii},
{"Games::DungeonMakerc::pair_ii_first_set", _wrap_pair_ii_first_set},
{"Games::DungeonMakerc::pair_ii_first_get", _wrap_pair_ii_first_get},
{"Games::DungeonMakerc::pair_ii_second_set", _wrap_pair_ii_second_set},
{"Games::DungeonMakerc::pair_ii_second_get", _wrap_pair_ii_second_get},
{"Games::DungeonMakerc::delete_pair_ii", _wrap_delete_pair_ii},
{"Games::DungeonMakerc::IntCoordinate_ShowX", _wrap_IntCoordinate_ShowX},
{"Games::DungeonMakerc::IntCoordinate_ShowY", _wrap_IntCoordinate_ShowY},
{"Games::DungeonMakerc::new_IntCoordinate", _wrap_new_IntCoordinate},
{"Games::DungeonMakerc::delete_IntCoordinate", _wrap_delete_IntCoordinate},
{"Games::DungeonMakerc::TransformDirection", _wrap_TransformDirection},
{"Games::DungeonMakerc::SquareInfo_xCoord_set", _wrap_SquareInfo_xCoord_set},
{"Games::DungeonMakerc::SquareInfo_xCoord_get", _wrap_SquareInfo_xCoord_get},
{"Games::DungeonMakerc::SquareInfo_yCoord_set", _wrap_SquareInfo_yCoord_set},
{"Games::DungeonMakerc::SquareInfo_yCoord_get", _wrap_SquareInfo_yCoord_get},
{"Games::DungeonMakerc::SquareInfo_type_set", _wrap_SquareInfo_type_set},
{"Games::DungeonMakerc::SquareInfo_type_get", _wrap_SquareInfo_type_get},
{"Games::DungeonMakerc::new_SquareInfo", _wrap_new_SquareInfo},
{"Games::DungeonMakerc::delete_SquareInfo", _wrap_delete_SquareInfo},
{"Games::DungeonMakerc::SpawnInfo_xCoord_set", _wrap_SpawnInfo_xCoord_set},
{"Games::DungeonMakerc::SpawnInfo_xCoord_get", _wrap_SpawnInfo_xCoord_get},
{"Games::DungeonMakerc::SpawnInfo_yCoord_set", _wrap_SpawnInfo_yCoord_set},
{"Games::DungeonMakerc::SpawnInfo_yCoord_get", _wrap_SpawnInfo_yCoord_get},
{"Games::DungeonMakerc::SpawnInfo_type_set", _wrap_SpawnInfo_type_set},
{"Games::DungeonMakerc::SpawnInfo_type_get", _wrap_SpawnInfo_type_get},
{"Games::DungeonMakerc::new_SpawnInfo", _wrap_new_SpawnInfo},
{"Games::DungeonMakerc::delete_SpawnInfo", _wrap_delete_SpawnInfo},
{"Games::DungeonMakerc::TripleInt_sm_set", _wrap_TripleInt_sm_set},
{"Games::DungeonMakerc::TripleInt_sm_get", _wrap_TripleInt_sm_get},
{"Games::DungeonMakerc::TripleInt_md_set", _wrap_TripleInt_md_set},
{"Games::DungeonMakerc::TripleInt_md_get", _wrap_TripleInt_md_get},
{"Games::DungeonMakerc::TripleInt_lg_set", _wrap_TripleInt_lg_set},
{"Games::DungeonMakerc::TripleInt_lg_get", _wrap_TripleInt_lg_get},
{"Games::DungeonMakerc::new_TripleInt", _wrap_new_TripleInt},
{"Games::DungeonMakerc::delete_TripleInt", _wrap_delete_TripleInt},
{"Games::DungeonMakerc::FlagsDirs_checked_set", _wrap_FlagsDirs_checked_set},
{"Games::DungeonMakerc::FlagsDirs_checked_get", _wrap_FlagsDirs_checked_get},
{"Games::DungeonMakerc::new_FlagsDirs", _wrap_new_FlagsDirs},
{"Games::DungeonMakerc::delete_FlagsDirs", _wrap_delete_FlagsDirs},
{"Games::DungeonMakerc::RectFill_startX_set", _wrap_RectFill_startX_set},
{"Games::DungeonMakerc::RectFill_startX_get", _wrap_RectFill_startX_get},
{"Games::DungeonMakerc::RectFill_startY_set", _wrap_RectFill_startY_set},
{"Games::DungeonMakerc::RectFill_startY_get", _wrap_RectFill_startY_get},
{"Games::DungeonMakerc::RectFill_endX_set", _wrap_RectFill_endX_set},
{"Games::DungeonMakerc::RectFill_endX_get", _wrap_RectFill_endX_get},
{"Games::DungeonMakerc::RectFill_endY_set", _wrap_RectFill_endY_set},
{"Games::DungeonMakerc::RectFill_endY_get", _wrap_RectFill_endY_get},
{"Games::DungeonMakerc::RectFill_type_set", _wrap_RectFill_type_set},
{"Games::DungeonMakerc::RectFill_type_get", _wrap_RectFill_type_get},
{"Games::DungeonMakerc::new_RectFill", _wrap_new_RectFill},
{"Games::DungeonMakerc::delete_RectFill", _wrap_delete_RectFill},
{"Games::DungeonMakerc::CrawlerData_loc_set", _wrap_CrawlerData_loc_set},
{"Games::DungeonMakerc::CrawlerData_loc_get", _wrap_CrawlerData_loc_get},
{"Games::DungeonMakerc::CrawlerData_dir_set", _wrap_CrawlerData_dir_set},
{"Games::DungeonMakerc::CrawlerData_dir_get", _wrap_CrawlerData_dir_get},
{"Games::DungeonMakerc::CrawlerData_intDir_set", _wrap_CrawlerData_intDir_set},
{"Games::DungeonMakerc::CrawlerData_intDir_get", _wrap_CrawlerData_intDir_get},
{"Games::DungeonMakerc::CrawlerData_age_set", _wrap_CrawlerData_age_set},
{"Games::DungeonMakerc::CrawlerData_age_get", _wrap_CrawlerData_age_get},
{"Games::DungeonMakerc::CrawlerData_maxAge_set", _wrap_CrawlerData_maxAge_set},
{"Games::DungeonMakerc::CrawlerData_maxAge_get", _wrap_CrawlerData_maxAge_get},
{"Games::DungeonMakerc::CrawlerData_gen_set", _wrap_CrawlerData_gen_set},
{"Games::DungeonMakerc::CrawlerData_gen_get", _wrap_CrawlerData_gen_get},
{"Games::DungeonMakerc::CrawlerData_sL_set", _wrap_CrawlerData_sL_set},
{"Games::DungeonMakerc::CrawlerData_sL_get", _wrap_CrawlerData_sL_get},
{"Games::DungeonMakerc::CrawlerData_op_set", _wrap_CrawlerData_op_set},
{"Games::DungeonMakerc::CrawlerData_op_get", _wrap_CrawlerData_op_get},
{"Games::DungeonMakerc::CrawlerData_cW_set", _wrap_CrawlerData_cW_set},
{"Games::DungeonMakerc::CrawlerData_cW_get", _wrap_CrawlerData_cW_get},
{"Games::DungeonMakerc::CrawlerData_sSSP_set", _wrap_CrawlerData_sSSP_set},
{"Games::DungeonMakerc::CrawlerData_sSSP_get", _wrap_CrawlerData_sSSP_get},
{"Games::DungeonMakerc::CrawlerData_sDSP_set", _wrap_CrawlerData_sDSP_set},
{"Games::DungeonMakerc::CrawlerData_sDSP_get", _wrap_CrawlerData_sDSP_get},
{"Games::DungeonMakerc::CrawlerData_tSSP_set", _wrap_CrawlerData_tSSP_set},
{"Games::DungeonMakerc::CrawlerData_tSSP_get", _wrap_CrawlerData_tSSP_get},
{"Games::DungeonMakerc::CrawlerData_tDSP_set", _wrap_CrawlerData_tDSP_set},
{"Games::DungeonMakerc::CrawlerData_tDSP_get", _wrap_CrawlerData_tDSP_get},
{"Games::DungeonMakerc::CrawlerData_cDP_set", _wrap_CrawlerData_cDP_set},
{"Games::DungeonMakerc::CrawlerData_cDP_get", _wrap_CrawlerData_cDP_get},
{"Games::DungeonMakerc::new_CrawlerData", _wrap_new_CrawlerData},
{"Games::DungeonMakerc::delete_CrawlerData", _wrap_delete_CrawlerData},
{"Games::DungeonMakerc::TunnelerData_loc_set", _wrap_TunnelerData_loc_set},
{"Games::DungeonMakerc::TunnelerData_loc_get", _wrap_TunnelerData_loc_get},
{"Games::DungeonMakerc::TunnelerData_dir_set", _wrap_TunnelerData_dir_set},
{"Games::DungeonMakerc::TunnelerData_dir_get", _wrap_TunnelerData_dir_get},
{"Games::DungeonMakerc::TunnelerData_intDir_set", _wrap_TunnelerData_intDir_set},
{"Games::DungeonMakerc::TunnelerData_intDir_get", _wrap_TunnelerData_intDir_get},
{"Games::DungeonMakerc::TunnelerData_age_set", _wrap_TunnelerData_age_set},
{"Games::DungeonMakerc::TunnelerData_age_get", _wrap_TunnelerData_age_get},
{"Games::DungeonMakerc::TunnelerData_maxAge_set", _wrap_TunnelerData_maxAge_set},
{"Games::DungeonMakerc::TunnelerData_maxAge_get", _wrap_TunnelerData_maxAge_get},
{"Games::DungeonMakerc::TunnelerData_gen_set", _wrap_TunnelerData_gen_set},
{"Games::DungeonMakerc::TunnelerData_gen_get", _wrap_TunnelerData_gen_get},
{"Games::DungeonMakerc::TunnelerData_sL_set", _wrap_TunnelerData_sL_set},
{"Games::DungeonMakerc::TunnelerData_sL_get", _wrap_TunnelerData_sL_get},
{"Games::DungeonMakerc::TunnelerData_tW_set", _wrap_TunnelerData_tW_set},
{"Games::DungeonMakerc::TunnelerData_tW_get", _wrap_TunnelerData_tW_get},
{"Games::DungeonMakerc::TunnelerData_sDSP_set", _wrap_TunnelerData_sDSP_set},
{"Games::DungeonMakerc::TunnelerData_sDSP_get", _wrap_TunnelerData_sDSP_get},
{"Games::DungeonMakerc::TunnelerData_tDSP_set", _wrap_TunnelerData_tDSP_set},
{"Games::DungeonMakerc::TunnelerData_tDSP_get", _wrap_TunnelerData_tDSP_get},
{"Games::DungeonMakerc::TunnelerData_cDP_set", _wrap_TunnelerData_cDP_set},
{"Games::DungeonMakerc::TunnelerData_cDP_get", _wrap_TunnelerData_cDP_get},
{"Games::DungeonMakerc::TunnelerData_mRRP_set", _wrap_TunnelerData_mRRP_set},
{"Games::DungeonMakerc::TunnelerData_mRRP_get", _wrap_TunnelerData_mRRP_get},
{"Games::DungeonMakerc::TunnelerData_mRLP_set", _wrap_TunnelerData_mRLP_set},
{"Games::DungeonMakerc::TunnelerData_mRLP_get", _wrap_TunnelerData_mRLP_get},
{"Games::DungeonMakerc::TunnelerData_jP_set", _wrap_TunnelerData_jP_set},
{"Games::DungeonMakerc::TunnelerData_jP_get", _wrap_TunnelerData_jP_get},
{"Games::DungeonMakerc::new_TunnelerData", _wrap_new_TunnelerData},
{"Games::DungeonMakerc::delete_TunnelerData", _wrap_delete_TunnelerData},
{"Games::DungeonMakerc::new_Room", _wrap_new_Room},
{"Games::DungeonMakerc::delete_Room", _wrap_delete_Room},
{"Games::DungeonMakerc::Room_AddSquare", _wrap_Room_AddSquare},
{"Games::DungeonMakerc::Room_GetInside", _wrap_Room_GetInside},
{"Games::DungeonMakerc::Room_SetInDungeon", _wrap_Room_SetInDungeon},
{"Games::DungeonMakerc::Room_GetInDungeon", _wrap_Room_GetInDungeon},
{"Games::DungeonMakerc::Room_GetSize", _wrap_Room_GetSize},
{"Games::DungeonMakerc::Room_GetRandomSquare", _wrap_Room_GetRandomSquare},
{"Games::DungeonMakerc::new_RoomComp", _wrap_new_RoomComp},
{"Games::DungeonMakerc::delete_RoomComp", _wrap_delete_RoomComp},
{"Games::DungeonMakerc::Config_dX_set", _wrap_Config_dX_set},
{"Games::DungeonMakerc::Config_dX_get", _wrap_Config_dX_get},
{"Games::DungeonMakerc::Config_dY_set", _wrap_Config_dY_set},
{"Games::DungeonMakerc::Config_dY_get", _wrap_Config_dY_get},
{"Games::DungeonMakerc::Config_bg_set", _wrap_Config_bg_set},
{"Games::DungeonMakerc::Config_bg_get", _wrap_Config_bg_get},
{"Games::DungeonMakerc::Config_op_set", _wrap_Config_op_set},
{"Games::DungeonMakerc::Config_op_get", _wrap_Config_op_get},
{"Games::DungeonMakerc::Config_des_set", _wrap_Config_des_set},
{"Games::DungeonMakerc::Config_des_get", _wrap_Config_des_get},
{"Games::DungeonMakerc::Config_SL_set", _wrap_Config_SL_set},
{"Games::DungeonMakerc::Config_SL_get", _wrap_Config_SL_get},
{"Games::DungeonMakerc::Config_CW_set", _wrap_Config_CW_set},
{"Games::DungeonMakerc::Config_CW_get", _wrap_Config_CW_get},
{"Games::DungeonMakerc::Config_MAC_set", _wrap_Config_MAC_set},
{"Games::DungeonMakerc::Config_MAC_get", _wrap_Config_MAC_get},
{"Games::DungeonMakerc::Config_MAT_set", _wrap_Config_MAT_set},
{"Games::DungeonMakerc::Config_MAT_get", _wrap_Config_MAT_get},
{"Games::DungeonMakerc::Config_Crawlers_set", _wrap_Config_Crawlers_set},
{"Games::DungeonMakerc::Config_Crawlers_get", _wrap_Config_Crawlers_get},
{"Games::DungeonMakerc::Config_Tunnelers_set", _wrap_Config_Tunnelers_set},
{"Games::DungeonMakerc::Config_Tunnelers_get", _wrap_Config_Tunnelers_get},
{"Games::DungeonMakerc::Config_CrawlerPairs_set", _wrap_Config_CrawlerPairs_set},
{"Games::DungeonMakerc::Config_CrawlerPairs_get", _wrap_Config_CrawlerPairs_get},
{"Games::DungeonMakerc::Config_BDPFGT_set", _wrap_Config_BDPFGT_set},
{"Games::DungeonMakerc::Config_BDPFGT_get", _wrap_Config_BDPFGT_get},
{"Games::DungeonMakerc::Config_BDPFGC_set", _wrap_Config_BDPFGC_set},
{"Games::DungeonMakerc::Config_BDPFGC_get", _wrap_Config_BDPFGC_get},
{"Games::DungeonMakerc::Config_BDPFGR_set", _wrap_Config_BDPFGR_set},
{"Games::DungeonMakerc::Config_BDPFGR_get", _wrap_Config_BDPFGR_get},
{"Games::DungeonMakerc::Config_RSPS_set", _wrap_Config_RSPS_set},
{"Games::DungeonMakerc::Config_RSPS_get", _wrap_Config_RSPS_get},
{"Games::DungeonMakerc::Config_RSPB_set", _wrap_Config_RSPB_set},
{"Games::DungeonMakerc::Config_RSPB_get", _wrap_Config_RSPB_get},
{"Games::DungeonMakerc::Config_mut_set", _wrap_Config_mut_set},
{"Games::DungeonMakerc::Config_mut_get", _wrap_Config_mut_get},
{"Games::DungeonMakerc::Config_nHP_set", _wrap_Config_nHP_set},
{"Games::DungeonMakerc::Config_nHP_get", _wrap_Config_nHP_get},
{"Games::DungeonMakerc::Config_jD_set", _wrap_Config_jD_set},
{"Games::DungeonMakerc::Config_jD_get", _wrap_Config_jD_get},
{"Games::DungeonMakerc::Config_minRS_set", _wrap_Config_minRS_set},
{"Games::DungeonMakerc::Config_minRS_get", _wrap_Config_minRS_get},
{"Games::DungeonMakerc::Config_medRS_set", _wrap_Config_medRS_set},
{"Games::DungeonMakerc::Config_medRS_get", _wrap_Config_medRS_get},
{"Games::DungeonMakerc::Config_larRS_set", _wrap_Config_larRS_set},
{"Games::DungeonMakerc::Config_larRS_get", _wrap_Config_larRS_get},
{"Games::DungeonMakerc::Config_maxRS_set", _wrap_Config_maxRS_set},
{"Games::DungeonMakerc::Config_maxRS_get", _wrap_Config_maxRS_get},
{"Games::DungeonMakerc::Config_numSmallL_set", _wrap_Config_numSmallL_set},
{"Games::DungeonMakerc::Config_numSmallL_get", _wrap_Config_numSmallL_get},
{"Games::DungeonMakerc::Config_numMedL_set", _wrap_Config_numMedL_set},
{"Games::DungeonMakerc::Config_numMedL_get", _wrap_Config_numMedL_get},
{"Games::DungeonMakerc::Config_numLarL_set", _wrap_Config_numLarL_set},
{"Games::DungeonMakerc::Config_numLarL_get", _wrap_Config_numLarL_get},
{"Games::DungeonMakerc::Config_numSmallD_set", _wrap_Config_numSmallD_set},
{"Games::DungeonMakerc::Config_numSmallD_get", _wrap_Config_numSmallD_get},
{"Games::DungeonMakerc::Config_numMedD_set", _wrap_Config_numMedD_set},
{"Games::DungeonMakerc::Config_numMedD_get", _wrap_Config_numMedD_get},
{"Games::DungeonMakerc::Config_numLarD_set", _wrap_Config_numLarD_set},
{"Games::DungeonMakerc::Config_numLarD_get", _wrap_Config_numLarD_get},
{"Games::DungeonMakerc::Config_rCPG_set", _wrap_Config_rCPG_set},
{"Games::DungeonMakerc::Config_rCPG_get", _wrap_Config_rCPG_get},
{"Games::DungeonMakerc::Config_rC_sSSP_set", _wrap_Config_rC_sSSP_set},
{"Games::DungeonMakerc::Config_rC_sSSP_get", _wrap_Config_rC_sSSP_get},
{"Games::DungeonMakerc::Config_rC_sDSP_set", _wrap_Config_rC_sDSP_set},
{"Games::DungeonMakerc::Config_rC_sDSP_get", _wrap_Config_rC_sDSP_get},
{"Games::DungeonMakerc::Config_rC_tSSP_set", _wrap_Config_rC_tSSP_set},
{"Games::DungeonMakerc::Config_rC_tSSP_get", _wrap_Config_rC_tSSP_get},
{"Games::DungeonMakerc::Config_rC_tDSP_set", _wrap_Config_rC_tDSP_set},
{"Games::DungeonMakerc::Config_rC_tDSP_get", _wrap_Config_rC_tDSP_get},
{"Games::DungeonMakerc::Config_rC_cDP_set", _wrap_Config_rC_cDP_set},
{"Games::DungeonMakerc::Config_rC_cDP_get", _wrap_Config_rC_cDP_get},
{"Games::DungeonMakerc::Config_jP_set", _wrap_Config_jP_set},
{"Games::DungeonMakerc::Config_jP_get", _wrap_Config_jP_get},
{"Games::DungeonMakerc::Config_sUpP_set", _wrap_Config_sUpP_set},
{"Games::DungeonMakerc::Config_sUpP_get", _wrap_Config_sUpP_get},
{"Games::DungeonMakerc::Config_sDownP_set", _wrap_Config_sDownP_set},
{"Games::DungeonMakerc::Config_sDownP_get", _wrap_Config_sDownP_get},
{"Games::DungeonMakerc::Config_pat_set", _wrap_Config_pat_set},
{"Games::DungeonMakerc::Config_pat_get", _wrap_Config_pat_get},
{"Games::DungeonMakerc::Config_tJD_set", _wrap_Config_tJD_set},
{"Games::DungeonMakerc::Config_tJD_get", _wrap_Config_tJD_get},
{"Games::DungeonMakerc::Config_sUGD_set", _wrap_Config_sUGD_set},
{"Games::DungeonMakerc::Config_sUGD_get", _wrap_Config_sUGD_get},
{"Games::DungeonMakerc::Config_cIT_set", _wrap_Config_cIT_set},
{"Games::DungeonMakerc::Config_cIT_get", _wrap_Config_cIT_get},
{"Games::DungeonMakerc::Config_rAR_set", _wrap_Config_rAR_set},
{"Games::DungeonMakerc::Config_rAR_get", _wrap_Config_rAR_get},
{"Games::DungeonMakerc::Config_aRP_set", _wrap_Config_aRP_set},
{"Games::DungeonMakerc::Config_aRP_get", _wrap_Config_aRP_get},
{"Games::DungeonMakerc::Config_gSUOAR_set", _wrap_Config_gSUOAR_set},
{"Games::DungeonMakerc::Config_gSUOAR_get", _wrap_Config_gSUOAR_get},
{"Games::DungeonMakerc::Config_crIT_set", _wrap_Config_crIT_set},
{"Games::DungeonMakerc::Config_crIT_get", _wrap_Config_crIT_get},
{"Games::DungeonMakerc::Config_crIA_set", _wrap_Config_crIA_set},
{"Games::DungeonMakerc::Config_crIA_get", _wrap_Config_crIA_get},
{"Games::DungeonMakerc::Config_sCIT_set", _wrap_Config_sCIT_set},
{"Games::DungeonMakerc::Config_sCIT_get", _wrap_Config_sCIT_get},
{"Games::DungeonMakerc::Config_showM_set", _wrap_Config_showM_set},
{"Games::DungeonMakerc::Config_showM_get", _wrap_Config_showM_get},
{"Games::DungeonMakerc::Config_storeM_set", _wrap_Config_storeM_set},
{"Games::DungeonMakerc::Config_storeM_get", _wrap_Config_storeM_get},
{"Games::DungeonMakerc::Config_TCS_set", _wrap_Config_TCS_set},
{"Games::DungeonMakerc::Config_TCS_get", _wrap_Config_TCS_get},
{"Games::DungeonMakerc::Config_randSeed_set", _wrap_Config_randSeed_set},
{"Games::DungeonMakerc::Config_randSeed_get", _wrap_Config_randSeed_get},
{"Games::DungeonMakerc::Config_MLR_set", _wrap_Config_MLR_set},
{"Games::DungeonMakerc::Config_MLR_get", _wrap_Config_MLR_get},
{"Games::DungeonMakerc::Config_MLO_set", _wrap_Config_MLO_set},
{"Games::DungeonMakerc::Config_MLO_get", _wrap_Config_MLO_get},
{"Games::DungeonMakerc::Config_MDR_set", _wrap_Config_MDR_set},
{"Games::DungeonMakerc::Config_MDR_get", _wrap_Config_MDR_get},
{"Games::DungeonMakerc::Config_MDO_set", _wrap_Config_MDO_set},
{"Games::DungeonMakerc::Config_MDO_get", _wrap_Config_MDO_get},
{"Games::DungeonMakerc::Config_TIL_set", _wrap_Config_TIL_set},
{"Games::DungeonMakerc::Config_TIL_get", _wrap_Config_TIL_get},
{"Games::DungeonMakerc::Config_TID_set", _wrap_Config_TID_set},
{"Games::DungeonMakerc::Config_TID_get", _wrap_Config_TID_get},
{"Games::DungeonMakerc::Config_gSMOBLR_set", _wrap_Config_gSMOBLR_set},
{"Games::DungeonMakerc::Config_gSMOBLR_get", _wrap_Config_gSMOBLR_get},
{"Games::DungeonMakerc::Config_gSMOBDR_set", _wrap_Config_gSMOBDR_set},
{"Games::DungeonMakerc::Config_gSMOBDR_get", _wrap_Config_gSMOBDR_get},
{"Games::DungeonMakerc::Config_gSTreasL_set", _wrap_Config_gSTreasL_set},
{"Games::DungeonMakerc::Config_gSTreasL_get", _wrap_Config_gSTreasL_get},
{"Games::DungeonMakerc::Config_gSTreasD_set", _wrap_Config_gSTreasD_set},
{"Games::DungeonMakerc::Config_gSTreasD_get", _wrap_Config_gSTreasD_get},
{"Games::DungeonMakerc::Config_gSVMOBLR_set", _wrap_Config_gSVMOBLR_set},
{"Games::DungeonMakerc::Config_gSVMOBLR_get", _wrap_Config_gSVMOBLR_get},
{"Games::DungeonMakerc::Config_gSVMOBDR_set", _wrap_Config_gSVMOBDR_set},
{"Games::DungeonMakerc::Config_gSVMOBDR_get", _wrap_Config_gSVMOBDR_get},
{"Games::DungeonMakerc::Config_gSVTreasL_set", _wrap_Config_gSVTreasL_set},
{"Games::DungeonMakerc::Config_gSVTreasL_get", _wrap_Config_gSVTreasL_get},
{"Games::DungeonMakerc::Config_gSVTreasD_set", _wrap_Config_gSVTreasD_set},
{"Games::DungeonMakerc::Config_gSVTreasD_get", _wrap_Config_gSVTreasD_get},
{"Games::DungeonMakerc::Config_iARP_set", _wrap_Config_iARP_set},
{"Games::DungeonMakerc::Config_iARP_get", _wrap_Config_iARP_get},
{"Games::DungeonMakerc::Config_tCG_set", _wrap_Config_tCG_set},
{"Games::DungeonMakerc::Config_tCG_get", _wrap_Config_tCG_get},
{"Games::DungeonMakerc::Config_tCCP_set", _wrap_Config_tCCP_set},
{"Games::DungeonMakerc::Config_tCCP_get", _wrap_Config_tCCP_get},
{"Games::DungeonMakerc::Config_lCT_set", _wrap_Config_lCT_set},
{"Games::DungeonMakerc::Config_lCT_get", _wrap_Config_lCT_get},
{"Games::DungeonMakerc::Config_gDLC_set", _wrap_Config_gDLC_set},
{"Games::DungeonMakerc::Config_gDLC_get", _wrap_Config_gDLC_get},
{"Games::DungeonMakerc::new_Config", _wrap_new_Config},
{"Games::DungeonMakerc::Config_ReadDesign", _wrap_Config_ReadDesign},
{"Games::DungeonMakerc::Config_AcceptDesign", _wrap_Config_AcceptDesign},
{"Games::DungeonMakerc::Config_ValidateDirections", _wrap_Config_ValidateDirections},
{"Games::DungeonMakerc::delete_Config", _wrap_delete_Config},
{"Games::DungeonMakerc::delete_Builder", _wrap_delete_Builder},
{"Games::DungeonMakerc::Builder_StepAhead", _wrap_Builder_StepAhead},
{"Games::DungeonMakerc::Builder_GetAge", _wrap_Builder_GetAge},
{"Games::DungeonMakerc::Builder_GetGeneration", _wrap_Builder_GetGeneration},
{"Games::DungeonMakerc::Builder_AdvanceAge", _wrap_Builder_AdvanceAge},
{"Games::DungeonMakerc::delete_WallCrawler", _wrap_delete_WallCrawler},
{"Games::DungeonMakerc::new_WallCrawler", _wrap_new_WallCrawler},
{"Games::DungeonMakerc::WallCrawler_FrontFree", _wrap_WallCrawler_FrontFree},
{"Games::DungeonMakerc::WallCrawler_StepAhead", _wrap_WallCrawler_StepAhead},
{"Games::DungeonMakerc::delete_Tunneler", _wrap_delete_Tunneler},
{"Games::DungeonMakerc::new_Tunneler", _wrap_new_Tunneler},
{"Games::DungeonMakerc::Tunneler_FrontFree", _wrap_Tunneler_FrontFree},
{"Games::DungeonMakerc::Tunneler_StepAhead", _wrap_Tunneler_StepAhead},
{"Games::DungeonMakerc::delete_Roomie", _wrap_delete_Roomie},
{"Games::DungeonMakerc::new_Roomie", _wrap_new_Roomie},
{"Games::DungeonMakerc::Roomie_StepAhead", _wrap_Roomie_StepAhead},
{"Games::DungeonMakerc::Roomie_FrontFree", _wrap_Roomie_FrontFree},
{"Games::DungeonMakerc::new_DungeonMaker", _wrap_new_DungeonMaker},
{"Games::DungeonMakerc::DungeonMaker_generate", _wrap_DungeonMaker_generate},
{"Games::DungeonMakerc::DungeonMaker_SetMap", _wrap_DungeonMaker_SetMap},
{"Games::DungeonMakerc::DungeonMaker_GetMap", _wrap_DungeonMaker_GetMap},
{"Games::DungeonMakerc::DungeonMaker_SetRect", _wrap_DungeonMaker_SetRect},
{"Games::DungeonMakerc::DungeonMaker_GetDimX", _wrap_DungeonMaker_GetDimX},
{"Games::DungeonMakerc::DungeonMaker_GetDimY", _wrap_DungeonMaker_GetDimY},
{"Games::DungeonMakerc::DungeonMaker_GetActiveGeneration", _wrap_DungeonMaker_GetActiveGeneration},
{"Games::DungeonMakerc::DungeonMaker_GetMinRoomSize", _wrap_DungeonMaker_GetMinRoomSize},
{"Games::DungeonMakerc::DungeonMaker_GetMaxRoomSize", _wrap_DungeonMaker_GetMaxRoomSize},
{"Games::DungeonMakerc::DungeonMaker_GetBackground", _wrap_DungeonMaker_GetBackground},
{"Games::DungeonMakerc::DungeonMaker_GetMovie", _wrap_DungeonMaker_GetMovie},
{"Games::DungeonMakerc::DungeonMaker_ShowMovie", _wrap_DungeonMaker_ShowMovie},
{"Games::DungeonMakerc::DungeonMaker_StoreMovie", _wrap_DungeonMaker_StoreMovie},
{"Games::DungeonMakerc::DungeonMaker_GetDesign", _wrap_DungeonMaker_GetDesign},
{"Games::DungeonMakerc::DungeonMaker_GetRooms", _wrap_DungeonMaker_GetRooms},
{"Games::DungeonMakerc::DungeonMaker_GetMOBs", _wrap_DungeonMaker_GetMOBs},
{"Games::DungeonMakerc::DungeonMaker_GetTreas", _wrap_DungeonMaker_GetTreas},
{"Games::DungeonMakerc::DungeonMaker_GetRoomSizeProbS", _wrap_DungeonMaker_GetRoomSizeProbS},
{"Games::DungeonMakerc::DungeonMaker_GetRoomSizeProbB", _wrap_DungeonMaker_GetRoomSizeProbB},
{"Games::DungeonMakerc::DungeonMaker_WantsMoreRoomsL", _wrap_DungeonMaker_WantsMoreRoomsL},
{"Games::DungeonMakerc::DungeonMaker_WantsMoreRoomsD", _wrap_DungeonMaker_WantsMoreRoomsD},
{"Games::DungeonMakerc::DungeonMaker_BuiltRoomD", _wrap_DungeonMaker_BuiltRoomD},
{"Games::DungeonMakerc::DungeonMaker_SortRooms", _wrap_DungeonMaker_SortRooms},
{"Games::DungeonMakerc::DungeonMaker_GetChangedThisIteration", _wrap_DungeonMaker_GetChangedThisIteration},
{"Games::DungeonMakerc::DungeonMaker_GetBabyDelayProbsForGenerationC", _wrap_DungeonMaker_GetBabyDelayProbsForGenerationC},
{"Games::DungeonMakerc::DungeonMaker_GetBabyDelayProbsForGenerationR", _wrap_DungeonMaker_GetBabyDelayProbsForGenerationR},
{"Games::DungeonMakerc::DungeonMaker_GetBabyDelayProbsForGenerationT", _wrap_DungeonMaker_GetBabyDelayProbsForGenerationT},
{"Games::DungeonMakerc::DungeonMaker_GetGenSpeeUpOnAnteRoom", _wrap_DungeonMaker_GetGenSpeeUpOnAnteRoom},
{"Games::DungeonMakerc::DungeonMaker_Mutate", _wrap_DungeonMaker_Mutate},
{"Games::DungeonMakerc::DungeonMaker_Mutate2", _wrap_DungeonMaker_Mutate2},
{"Games::DungeonMakerc::DungeonMaker_GetNoHeadingProb", _wrap_DungeonMaker_GetNoHeadingProb},
{"Games::DungeonMakerc::DungeonMaker_GetStepLength", _wrap_DungeonMaker_GetStepLength},
{"Games::DungeonMakerc::DungeonMaker_GetCorrWidth", _wrap_DungeonMaker_GetCorrWidth},
{"Games::DungeonMakerc::DungeonMaker_GetMaxAgeC", _wrap_DungeonMaker_GetMaxAgeC},
{"Games::DungeonMakerc::DungeonMaker_GetMaxAgeT", _wrap_DungeonMaker_GetMaxAgeT},
{"Games::DungeonMakerc::DungeonMaker_GetAnteRoomProb", _wrap_DungeonMaker_GetAnteRoomProb},
{"Games::DungeonMakerc::DungeonMaker_GetJoinDist", _wrap_DungeonMaker_GetJoinDist},
{"Games::DungeonMakerc::DungeonMaker_GetSizeUpGenDelay", _wrap_DungeonMaker_GetSizeUpGenDelay},
{"Games::DungeonMakerc::DungeonMaker_GetTunnelJoinDist", _wrap_DungeonMaker_GetTunnelJoinDist},
{"Games::DungeonMakerc::DungeonMaker_CreateCrawler", _wrap_DungeonMaker_CreateCrawler},
{"Games::DungeonMakerc::DungeonMaker_CreateTunneler", _wrap_DungeonMaker_CreateTunneler},
{"Games::DungeonMakerc::DungeonMaker_CreateRoomie", _wrap_DungeonMaker_CreateRoomie},
{"Games::DungeonMakerc::DungeonMaker_MakeIteration", _wrap_DungeonMaker_MakeIteration},
{"Games::DungeonMakerc::DungeonMaker_AdvanceGeneration", _wrap_DungeonMaker_AdvanceGeneration},
{"Games::DungeonMakerc::DungeonMaker_CreateRoom", _wrap_DungeonMaker_CreateRoom},
{"Games::DungeonMakerc::DungeonMaker_GetJoinPref", _wrap_DungeonMaker_GetJoinPref},
{"Games::DungeonMakerc::DungeonMaker_GetSizeUpProb", _wrap_DungeonMaker_GetSizeUpProb},
{"Games::DungeonMakerc::DungeonMaker_GetSizeDownProb", _wrap_DungeonMaker_GetSizeDownProb},
{"Games::DungeonMakerc::DungeonMaker_GetPatience", _wrap_DungeonMaker_GetPatience},
{"Games::DungeonMakerc::DungeonMaker_GetRoomAspectRatio", _wrap_DungeonMaker_GetRoomAspectRatio},
{"Games::DungeonMakerc::DungeonMaker_WeWantColumnsInTunnels", _wrap_DungeonMaker_WeWantColumnsInTunnels},
{"Games::DungeonMakerc::DungeonMaker_CrawlersInTunnels", _wrap_DungeonMaker_CrawlersInTunnels},
{"Games::DungeonMakerc::DungeonMaker_CrawlersInAnterooms", _wrap_DungeonMaker_CrawlersInAnterooms},
{"Games::DungeonMakerc::DungeonMaker_SeedCrawlersInTunnels", _wrap_DungeonMaker_SeedCrawlersInTunnels},
{"Games::DungeonMakerc::DungeonMaker_GetTunnelCrawlerGeneration", _wrap_DungeonMaker_GetTunnelCrawlerGeneration},
{"Games::DungeonMakerc::DungeonMaker_GetLastChanceRoomsRightProb", _wrap_DungeonMaker_GetLastChanceRoomsRightProb},
{"Games::DungeonMakerc::DungeonMaker_GetLastChanceRoomsLeftProb", _wrap_DungeonMaker_GetLastChanceRoomsLeftProb},
{"Games::DungeonMakerc::DungeonMaker_GetLastChanceChangeDirProb", _wrap_DungeonMaker_GetLastChanceChangeDirProb},
{"Games::DungeonMakerc::DungeonMaker_GetLastChanceStraightSpawnProb", _wrap_DungeonMaker_GetLastChanceStraightSpawnProb},
{"Games::DungeonMakerc::DungeonMaker_GetLastChanceTurnSpawnProb", _wrap_DungeonMaker_GetLastChanceTurnSpawnProb},
{"Games::DungeonMakerc::DungeonMaker_GetLastChanceGenDelay", _wrap_DungeonMaker_GetLastChanceGenDelay},
{"Games::DungeonMakerc::DungeonMaker_AddRoom", _wrap_DungeonMaker_AddRoom},
{"Games::DungeonMakerc::DungeonMaker_NumberOfRooms", _wrap_DungeonMaker_NumberOfRooms},
{"Games::DungeonMakerc::DungeonMaker_RoomNumber", _wrap_DungeonMaker_RoomNumber},
{"Games::DungeonMakerc::DungeonMaker_PlonkDownStuff", _wrap_DungeonMaker_PlonkDownStuff},
{"Games::DungeonMakerc::DungeonMaker_PutPlonkOnMap", _wrap_DungeonMaker_PutPlonkOnMap},
{"Games::DungeonMakerc::DungeonMaker_IsChecked", _wrap_DungeonMaker_IsChecked},
{"Games::DungeonMakerc::DungeonMaker_SetChecked", _wrap_DungeonMaker_SetChecked},
{"Games::DungeonMakerc::DungeonMaker_SetUnchecked", _wrap_DungeonMaker_SetUnchecked},
{"Games::DungeonMakerc::delete_DungeonMaker", _wrap_delete_DungeonMaker},
{0,0}
};
/*************************************************************************
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.

 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop though that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.

 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
**/

#ifdef __cplusplus
extern "C" {
#endif
    
    SWIGRUNTIME void
    SWIG_InitializeModule(void *clientdata) {
        swig_type_info *type, *ret;
        swig_cast_info *cast;
        size_t i;
        swig_module_info *module_head;
        static int init_run = 0;
        
        clientdata = clientdata;
        
        if (init_run) return;
        init_run = 1;
        
        /* Initialize the swig_module */
        swig_module.type_initial = swig_type_initial;
        swig_module.cast_initial = swig_cast_initial;
        
        /* Try and load any already created modules */
        module_head = SWIG_GetModule(clientdata);
        if (module_head) {
            swig_module.next = module_head->next;
            module_head->next = &swig_module;
        } else {
            /* This is the first module loaded */
            swig_module.next = &swig_module;
            SWIG_SetModule(clientdata, &swig_module);
        }
        
        /* Now work on filling in swig_module.types */
        for (i = 0; i < swig_module.size; ++i) {
            type = 0;
            
            /* if there is another module already loaded */
            if (swig_module.next != &swig_module) {
                type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
            }
            if (type) {
                /* Overwrite clientdata field */
                if (swig_module.type_initial[i]->clientdata) type->clientdata = swig_module.type_initial[i]->clientdata;
            } else {
                type = swig_module.type_initial[i];
            }
            
            /* Insert casting types */
            cast = swig_module.cast_initial[i];
            while (cast->type) {
                /* Don't need to add information already in the list */
                ret = 0;
                if (swig_module.next != &swig_module) {
                    ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
                }
                if (ret && type == swig_module.type_initial[i]) {
                    cast->type = ret;
                    ret = 0;
                }
                
                if (!ret) {
                    if (type->cast) {
                        type->cast->prev = cast;
                        cast->next = type->cast;
                    }
                    type->cast = cast;
                }
                
                cast++;
            }
            
            /* Set entry in modules->types array equal to the type */
            swig_module.types[i] = type;
        }
        swig_module.types[i] = 0;
    }
    
    /* This function will propagate the clientdata field of type to
    * any new swig_type_info structures that have been added into the list
    * of equivalent types.  It is like calling
    * SWIG_TypeClientData(type, clientdata) a second time.
    */
    SWIGRUNTIME void
    SWIG_PropagateClientData(void) {
        size_t i;
        swig_cast_info *equiv;
        static int init_run = 0;
        
        if (init_run) return;
        init_run = 1;
        
        for (i = 0; i < swig_module.size; i++) {
            if (swig_module.types[i]->clientdata) {
                equiv = swig_module.types[i]->cast;
                while (equiv) {
                    if (!equiv->converter) {
                        if (equiv->type && !equiv->type->clientdata)
                        SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
                    }
                    equiv = equiv->next;
                }
            }
        }
    }
    
#ifdef __cplusplus
}
#endif



#ifdef __cplusplus
extern "C"
#endif

XS(SWIG_init) {
    dXSARGS;
    int i;
    
    SWIG_InitializeModule(0);
    
    /* Install commands */
    for (i = 0; swig_commands[i].name; i++) {
        newXS((char*) swig_commands[i].name,swig_commands[i].wrapper, (char*)__FILE__);
    }
    
    /* Install variables */
    for (i = 0; swig_variables[i].name; i++) {
        SV *sv;
        sv = perl_get_sv((char*) swig_variables[i].name, TRUE | 0x2);
        if (swig_variables[i].type) {
            SWIG_MakePtr(sv,(void *)1, *swig_variables[i].type,0);
        } else {
            sv_setiv(sv,(IV) 0);
        }
        swig_create_magic(sv, (char *) swig_variables[i].name, swig_variables[i].set, swig_variables[i].get); 
    }
    
    /* Install constant */
    for (i = 0; swig_constants[i].type; i++) {
        SV *sv;
        sv = perl_get_sv((char*)swig_constants[i].name, TRUE | 0x2);
        switch(swig_constants[i].type) {
            case SWIG_INT:
            sv_setiv(sv, (IV) swig_constants[i].lvalue);
            break;
            case SWIG_FLOAT:
            sv_setnv(sv, (double) swig_constants[i].dvalue);
            break;
            case SWIG_STRING:
            sv_setpv(sv, (char *) swig_constants[i].pvalue);
            break;
            case SWIG_POINTER:
            SWIG_MakePtr(sv, swig_constants[i].pvalue, *(swig_constants[i].ptype),0);
            break;
            case SWIG_BINARY:
            SWIG_MakePackedObj(sv, swig_constants[i].pvalue, swig_constants[i].lvalue, *(swig_constants[i].ptype));
            break;
            default:
            break;
        }
        SvREADONLY_on(sv);
    }
    
    SWIG_TypeClientData(SWIGTYPE_p_std__pairTint_int_t, (void*) "Games::DungeonMaker::pair_ii");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__IntCoordinate, (void*) "Games::DungeonMaker::IntCoordinate");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__SquareInfo, (void*) "Games::DungeonMaker::SquareInfo");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__SpawnInfo, (void*) "Games::DungeonMaker::SpawnInfo");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__TripleInt, (void*) "Games::DungeonMaker::TripleInt");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__FlagsDirs, (void*) "Games::DungeonMaker::FlagsDirs");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__RectFill, (void*) "Games::DungeonMaker::RectFill");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__CrawlerData, (void*) "Games::DungeonMaker::CrawlerData");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__TunnelerData, (void*) "Games::DungeonMaker::TunnelerData");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__Room, (void*) "Games::DungeonMaker::Room");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__RoomComp, (void*) "Games::DungeonMaker::RoomComp");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__Config, (void*) "Games::DungeonMaker::Config");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__Builder, (void*) "Games::DungeonMaker::Builder");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__WallCrawler, (void*) "Games::DungeonMaker::WallCrawler");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__Tunneler, (void*) "Games::DungeonMaker::Tunneler");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__Roomie, (void*) "Games::DungeonMaker::Roomie");
    SWIG_TypeClientData(SWIGTYPE_p_alifegames__DungeonMaker, (void*) "Games::DungeonMaker::DungeonMaker");
    ST(0) = &PL_sv_yes;
    XSRETURN(1);
}

